̥---
title: "RNA-seq FRDA Analysis Pipeline"
author: "Ankit Mukherjee"
output: html_document
---

# Load Libraries
```{r}
library(DESeq2)
library(limma)
library(sva)
library(tidyverse)
library(readxl)
library(writexl)
library(openxlsx)
library(ggplot2)
library(BiocParallel)
library(patchwork)
library(ggrepel)
library(GSEABase)
library(Biobase)
library(GSVA)
library(gprofiler2)
library(clusterProfiler)
library(enrichR)
library(msigdbr)
library(enrichplot)
library(org.Hs.eg.db)
library(ComplexHeatmap)
library(WGCNA)
library(gridExtra)
library(CorLevelPlot)
```

# Load RDS Files
```{r}
rds_files <- list.files(path = "salmon/", pattern = "\\.rds$", full.names = TRUE)
rds_list <- lapply(rds_files, readRDS)
names(rds_list) <- basename(rds_files)
```

# Load & Prepare Metadata
```{r}
attributes_frda <- read_xlsx("Metadata_RNAseq_FAvsHC.xlsx") |> subset(select = -Sno)
severity_scoring_frda <- read_xlsx("severity scoring.xlsx")
metadata_frda <- merge(attributes_frda, severity_scoring_frda, by = "Raw Data ID", all.x = TRUE)

metadata_frda$Batch <- factor(as.numeric(metadata_frda$Batch))
metadata_frda$Sex <- factor(metadata_frda$Sex)
metadata_frda$Age_scaled <- scale(as.numeric(metadata_frda$Age))
metadata_frda$Condition <- factor(metadata_frda$Condition, levels = c("Control", "Patient"))
metadata_frda$FSA_scaled <- scale(as.numeric(metadata_frda$`FSA scale`))
metadata_frda$mFARS_scaled <- scale(as.numeric(metadata_frda$`mFARS total`))
metadata_frda$mFARS_USS_scaled <- scale(as.numeric(metadata_frda$`mFARS USS`))
metadata_frda$DD_scaled <- scale(as.numeric(metadata_frda$DD))
metadata_frda$Onset_scaled <- scale(as.numeric(metadata_frda$Onset))
metadata_frda$HCM <- factor(as.numeric(metadata_frda$HCM), levels = c(0, 1))
metadata_frda$Diabetes <- factor(as.numeric(metadata_frda$Diabetes), levels = c(0, 1))
metadata_frda$GAA1_scaled <- scale(as.numeric(metadata_frda$GAA1))
metadata_frda$GAA2_scaled <- scale(as.numeric(metadata_frda$GAA2))

rownames(metadata_frda) <- metadata_frda$`Raw Data ID`
metadata_frda <- subset(metadata_frda, select = -`Raw Data ID`)
metadata_frda[metadata_frda == "NA"] <- NA

# Matching the rownames of all except the first to the first
all(sapply(rds_list[-1], function(x) identical(rownames(assay(x)), rownames(assay(rds_list[[1]])))))
```

# Clean Sample Sets
```{r}
# Removing batch3 top up samples from batch3
samples_to_remove <- intersect(colnames(assay(rds_list[[3]])), colnames(assay(rds_list[[4]])))
rds_list[[3]] <- rds_list[[3]][, !colnames(assay(rds_list[[3]])) %in% samples_to_remove]

# Remove PC samples in Batch8
rds_list[[9]] <- rds_list[[9]][, !colnames(assay(rds_list[[9]])) %in% c("PC1", "PC2", "PC3")]
```

# Combine Count Data
```{r}
combined_rds <- do.call(cbind, rds_list)
count_data <- assay(combined_rds)
count_data <- count_data[, sort(colnames(count_data))]

# Replace Ensembl IDs with gene names
gene_names <- rowData(rds_list[[1]])$gene_name
rownames(count_data) <- make.unique(gene_names)

# Filter low-expression genes
dim(count_data)
count_data_filtered <- count_data[rowSums(count_data >= 10) >= 5, ]
dim(count_data_filtered)
```

# Check Design Matrix
```{r}
# Check whether the model matrix is full rank or not 
# (i.e. there are no collinearities between covariates in the design formula)
check_design_collinearity <- function(formula, data) {
  design_matrix <- model.matrix(formula, data = data)
  # Check rank
  is_full_rank <- qr(design_matrix)$rank == ncol(design_matrix) # QR decomposition to check rank
  cat("Design matrix full rank: ", is_full_rank, "\n")
  if (!is_full_rank) {
    cat("\nDetected linear dependencies:\n")
    lm_obj <- lm(rep(1, nrow(design_matrix)) ~ design_matrix) # Fit linear model to identify dependencies
    print(alias(lm_obj)) # Display linear dependencies
  } else {
    cat("No linear dependencies detected.\n")
  }
  invisible(design_matrix)
}
```

# Differential expression between patients and controls from all batches
```{r}
all.equal(rownames(metadata_frda), colnames(count_data_filtered))
# dds <- DESeqDataSetFromMatrix(countData = round(count_data_filtered), 
#                               colData = metadata_frda, 
#                               design = ~ Batch + Sex + Age_scaled + Condition)
# dds <- estimateSizeFactors(dds)
# dds <- DESeq(dds, parallel = TRUE)
# saveRDS(dds, "dds_frda.rds")
dds <- readRDS("dds_frda.rds")
```

# Batch Correction
```{r}
vsd <- vst(dds, blind = FALSE)
expr_vst <- assay(vsd)
covs <- model.matrix(~ Sex + Age + Condition, data = metadata_frda)
expr_rb <- limma::removeBatchEffect(expr_vst, batch = metadata_frda$Batch, design = covs)
```

# PCA Plot Function
```{r}
# PCA plot before and after removing batch effects with top 500 variable genes
# plotPCA(vsd, intgroup = c("Batch", "Condition")) # before batch effect removal
# or
plot_pca <- function(expr_matrix, metadata, top_n = 500, color_by, shape_by, title) {
  metadata <- metadata[colnames(expr_matrix), , drop = FALSE]
  topVarGenes <- order(matrixStats::rowVars(expr_matrix), decreasing = TRUE)[seq_len(top_n)]
  
  pca_res <- prcomp(t(expr_matrix[topVarGenes, ]))
  percent_var <- pca_res$sdev^2 / sum(pca_res$sdev^2)
  
  pca_data <- data.frame(
    Sample = colnames(expr_matrix),
    PC1 = pca_res$x[, 1],
    PC2 = pca_res$x[, 2],
    Color = metadata[[color_by]]
  )
  
  if (!is.null(shape_by)) {
    pca_data$Shape <- metadata[[shape_by]]
  }
  
  pca_data <- na.omit(pca_data)
  
  p <- ggplot(pca_data, aes(x = PC1, y = PC2)) +
    geom_point(
      aes(color = Color, shape = if (!is.null(shape_by)) Shape else NULL),
      size = 3, alpha = 0.8
    ) +
    theme_bw(base_size = 14) +
    labs(
      title = title,
      x = paste0("PC1: ", round(percent_var[1] * 100, 1), "% variance"),
      y = paste0("PC2: ", round(percent_var[2] * 100, 1), "% variance"),
      color = color_by,
      shape = shape_by
    ) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "right"
    )
  
  return(p)
}
```

# DGE
```{r}
# coef from resultsNames(dds)
# res_contrast <- results(dds, contrast = c("Condition", "Patient", "Control")) |> 
#   as.data.frame() |> 
#   rownames_to_column("gene_names")

# res <- lfcShrink(dds, coef = "Condition_Patient_vs_Control", type = "apeglm", parallel = TRUE) |> 
#   as.data.frame() |> 
#   rownames_to_column("gene_names")
# saveRDS(res, "res_frda.rds")
res <- readRDS("res_frda.rds")
```

# Volcano Plot Function
```{r}
volcano_plot <- function(res,
                         gene_label_col,
                         lfc_threshold = 2,
                         padj_threshold = 0.01,
                         top_n = 10,
                         base_size = 14) {

  vol_data <- res |>
    na.omit() |> 
    mutate(Expression = case_when(
      log2FoldChange >= lfc_threshold & padj <= padj_threshold ~ "Upregulated",
      log2FoldChange <= -lfc_threshold & padj <= padj_threshold ~ "Downregulated",
      TRUE ~ "Not significant"
    ))

  top_up <- vol_data |>
    filter(Expression == "Upregulated") |>
    arrange(padj) |>
    head(top_n)
  
  top_down <- vol_data |>
    filter(Expression == "Downregulated") |>
    arrange(padj) |>
    head(top_n)
  
  top_genes <- bind_rows(top_up, top_down)

  p <- ggplot(vol_data, aes(x = log2FoldChange, y = -log10(padj))) +
    geom_point(aes(color = Expression)) +
    geom_text_repel(
      data = top_genes,
      aes(label = .data[[gene_label_col]]),
      size = 4,
      max.overlaps = 15
    ) +
    scale_color_manual(values = c(
      "Upregulated" = "#D55E00",
      "Downregulated" = "#0072B2",
      "Not significant" = "gray70"
    )) +
    scale_x_continuous(name = "Log2 fold change") +
    scale_y_continuous(name = "-Log10 adjusted p-value") +
    geom_hline(yintercept = -log10(padj_threshold), linetype = 2, color = "black") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = 2, color = "black") +
    theme_classic(base_size = base_size) +
    theme(
      panel.grid = element_blank(),
      plot.background = element_rect(fill = "white"),
      legend.position = "right"
    )
  
  return(p)
}
```

# Comparing FXN expression levels across patients and controls
```{r, eval=FALSE}
fxn_rb <- expr_rb["FXN", ]
fxn_df_pre <- count_data["FXN", ] |> 
              rownames_to_column("Gene") |> 
              pivot_longer(cols = -Gene, names_to = "SampleID", values_to = "fxn_pre") |> 
              select(-Gene)
fxn_df_post <- fxn_rb |> as.data.frame() |> rownames_to_column("SampleID")
write_xlsx(fxn_df_pre, "fxn_df_pre.xlsx")
write_xlsx(fxn_df_post, "fxn_exp.xlsx")

data_fxn <- metadata_frda
data_fxn$FXN_expression <- fxn_rb
data_fxn <- data_fxn[order(data_fxn$FXN_expression), ]
data_fxn <- data_fxn |> rownames_to_column("SampleID")
highlight_samples <- c("FA18", "FA25", "FA43", "FA45")
data_fxn$highlight <- ifelse(data_fxn$SampleID %in% highlight_samples, "Highlight", "Other")

fxn_exp <- ggplot(data_fxn, aes(x = reorder(SampleID, FXN_expression),
                      y = FXN_expression)) +
  geom_point(aes(color = Condition, alpha = highlight, size = highlight)) +
  scale_alpha_manual(values = c("Other" = 0.5, "Highlight" = 1)) +
  scale_size_manual(values = c("Other" = 2, "Highlight" = 4)) +
  geom_text(data = subset(data_fxn, highlight == "Highlight"),
            aes(label = SampleID),
            vjust = -1.0, size = 3, color = "black", fontface = "bold") +
  theme_bw(base_size = 14) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Samples", y = "FXN expression")

ggsave("fxn_exp.jpeg",
        plot = fxn_exp, 
        device = "jpeg",
        units = "in",
        height = 8,
        width = 25,
        dpi = 600)
```

# Segregating samples on the basis of batch effects into test and replication cohort

```{r, eval=FALSE}
# Removing samples FA18, HC8, FA43, FA25, FA81, FA45 and FA82 (from FXN exp plot)
samples_to_remove_fxn_abnormal <- c("FA18", "HC8", "FA43", "FA25", "FA81", "FA45", "FA82")
metadata_frda_remove_fxn_abnormal <- metadata_frda[!rownames(metadata_frda) %in% samples_to_remove_fxn_abnormal, ]
count_data_remove_fxn_abnormal <- count_data_filtered[, rownames(metadata_frda_remove_fxn_abnormal)]

pca_data <- plotPCA(vsd, intgroup = c("Batch", "Condition"), returnData = TRUE)
test_batches <- pca_data$Batch[pca_data$PC1 < 0] |> unique()
replication_batches <- pca_data$Batch[pca_data$PC1 > 0] |> unique()

test_metadata <- metadata_frda_remove_fxn_abnormal[metadata_frda_remove_fxn_abnormal$Batch %in% test_batches, ]
test_count_data <- count_data_filtered[, rownames(test_metadata)]
replication_metadata <- metadata_frda_remove_fxn_abnormal[metadata_frda_remove_fxn_abnormal$Batch %in% replication_batches, ]
replication_count_data <- count_data_filtered[, rownames(replication_metadata)]
```

# DGE function
```{r}
dge <- function(counts, meta, design, filename, filename_volcano) {
  library(DESeq2)
  library(writexl)
  library(ggplot2)

  dds <- DESeqDataSetFromMatrix(countData = round(counts),
                                colData = meta,
                                design = design)
  dds <- DESeq(dds, parallel = FALSE)
  save_dds <- readline(prompt = "Save DESeqDataSet object? (yes/no): ")
  if (tolower(save_dds) == "yes") {
    dds_filename <- readline(prompt = "Enter filename to save DESeqDataSet object (e.g., dds.rds): ")
    saveRDS(dds, dds_filename)
  }
  
  cat("\nCoefficients:\n")
  print(resultsNames(dds))

  mode_choice <- readline(prompt = "\nUse 'coef' or 'contrast'? ")
  
  if (tolower(mode_choice) == "coef") {
    coef_choice <- readline(prompt = "Enter the coefficient name: ")
    res <- lfcShrink(dds, coef = coef_choice, type = "apeglm") |>
      as.data.frame() |>
      rownames_to_column("gene_names")
    
  } else if (tolower(mode_choice) == "contrast") {
    cat("\nEnter contrast as a single R expression.\n")
    cat("Examples:\n")
    cat("# Biological Question                               | Intercept Model (~ genotype + cond + g:c)                    | No-Intercept Model (~ 0 + group)\n")
    cat("# --------------------------------------------------------------------------------------------------------------------------\n")
    cat("# Condition effect in Genotype I (B vs A in I)       | results(dds, name=\"condition_B_vs_A\")                     | results(dds, contrast=list(\"groupI_B\", \"groupI_A\"))\n")
    cat("# Condition effect in Genotype II (B vs A in II)     | results(dds, list(c(\"condition_B_vs_A\", \"genotypeII.conditionB\"))) | results(dds, contrast=list(\"groupII_B\", \"groupII_A\"))\n")
    cat("# Interaction effect (Is B vs A different in II vs I?) | results(dds, name=\"genotypeII.conditionB\")               | results(dds, contrast=list(c(\"groupII_B\", \"groupI_A\"), c(\"groupII_A\", \"groupI_B\")))\n")
    cat("# ---------------------------------------------------------------------------\n")
    cat("Wrap the contrast in list(), e.g. list(\"Condition_Treated_vs_Control\") or list(\"Batch1.ConditionControl\", \"Batch9.ConditionControl\")\n\n")
    
    contrast_input <- readline(prompt = "Enter your contrast: ")
    contrast_list <- eval(parse(text = contrast_input))
    
    res <- lfcShrink(dds, contrast = contrast_list, type = "ashr") |>
      as.data.frame() |>
      rownames_to_column("gene_names")
    
  } else {
    stop("Invalid input")
  }
  
  resOrdered <- res[order(res$padj), ]
  write_xlsx(resOrdered, filename)
  
  volcano <- volcano_plot(resOrdered, gene_label_col = "gene_names")
  ggsave(
    filename = filename_volcano,
    plot = volcano,
    device = "jpeg",
    units = "in",
    height = 8,
    width = 15,
    dpi = 600
  )
  
  return(resOrdered)
}
```

# Finding differences between patients of Batches 1 to 7 and Batches 8 and 9
```{r, eval=FALSE}
metadata_frda_remove_fxn_abnormal <- metadata_frda_remove_fxn_abnormal |>
  mutate(Batch_group = ifelse(Batch %in% 1:7, "Batch 1-7", "Batch 8-9"),
         GAA1_GAA2 = GAA1 + GAA2) |>
  filter(Condition == "Patient") |>
  mutate(across(c(Age, DD, Onset, GAA1, GAA2, GAA1_GAA2), as.numeric))

plot_box_jitter_vars <- function(data, y_vars, group_col = "Batch_group") {
  
  plots <- lapply(y_vars, function(var) {
    ggplot(data, aes_string(x = group_col, y = var)) +
      geom_boxplot(outlier.shape = NA, fill = "lightblue") +
      geom_jitter(width = 0.2, size = 2, alpha = 0.7, color = "darkblue") +
      theme_bw(base_size = 14)
  })

  names(plots) <- y_vars
  return(plots)
}

vars_to_plot <- c("Age", "DD", "Onset", "GAA1", "GAA2", "GAA1_GAA2")
plots <- plot_box_jitter_vars(metadata_frda_remove_fxn_abnormal, vars_to_plot)
wrap_plots(plots, ncol = 3)

# Read alignment differences
reads_aligned <- read_excel("QC/QC/qc_result.xlsx", sheet = "millions_aligned")

p <- ggplot(reads_aligned, aes(x = Sample, y = `M Aligned`)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(`M Aligned`, 1)), vjust = -0.5, size = 6) +
  facet_grid(. ~ Condition + Batch, scales = "free_x", space = "free_x") +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw(base_size = 18) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Samples", y = "Millions aligned")

ggsave("QC/QC/reads_aligned.jpeg",
       plot = p,
       device = "jpeg",
       units = "in",
       height = 20,
       width = 50,
       dpi = 600,
       limitsize = FALSE)
```

# DE for batch 8 and 9 patients and controls
```{r}
# Selecting samples that have million mapped reads to the transcriptome > 5 
# and million mapped fragments to the exonic region of the genome > 10

qc_result <- read_excel("QC/qc_dragen_salmon.xlsx", skip = 1)
samples_qualified <- qc_result |>
  filter(`M Aligned` > 5 & `Exonic` > 10) |> # exonic info available for batch 8 and 9 only
  pull(Sample)

metadata_frda_batch8_9 <- metadata_frda |>
  filter(Batch %in% c(8, 9) & rownames(metadata_frda) %in% samples_qualified)
metadata_frda_batch8_9$Batch <- factor(metadata_frda_batch8_9$Batch)
count_data_frda_batch8_9 <- count_data_filtered[, rownames(metadata_frda_batch8_9)]

# batch8_9_result <- dge(counts = count_data_frda_batch8_9, 
#                       meta = metadata_frda_batch8_9,
#                       design = ~ Batch + Sex + Age_scaled + Condition,
#                       filename = "res/res_batch8_9_patients_vs_controls.xlsx",
#                       filename_volcano = "volcano_plot/volcano_batch8_9_patients_vs_controls.jpeg")
```

# Pathway Analysis for batch 8 and 9 DGE results
```{r}
dge_batch_8_9 <- read_xlsx("res/res_batch8_9_patients_vs_controls.xlsx")
top_genes <- dge_batch_8_9 |> 
  filter(padj < 0.01 & abs(log2FoldChange) >= 1) |> 
  pull(gene_names)
```

# GO enrichment (Overrepresentation analysis using hypergeometric test)
```{r, eval=FALSE}
go_gprofiler2 <- gost(query = top_genes,
                  organism = "hsapiens",
                  sources = c("GO:BP", "GO:MF", "GO:CC", "KEGG", "REAC", "TF"),
                  correction_method = "fdr",
                  user_threshold = 0.05,
                  significant = TRUE)

gostplot(go_gprofiler2, capped = TRUE, interactive = TRUE)

go_clusterprof <- enrichGO(gene = top_genes,
                            OrgDb = org.Hs.eg.db,
                            keyType = "SYMBOL",
                            ont = "ALL",
                            pAdjustMethod = "BH",
                            pvalueCutoff = 0.05,
                            qvalueCutoff = 0.05)

dotplot(go_clusterprof, showCategory = 20)
ggsave("pathway_enrichment/go_enrichment_batch8_9_patients_vs_controls.jpeg",
       plot = last_plot(),
       device = "jpeg",
       units = "in",
       height = 8,
       width = 12,
       dpi = 600)

write_xlsx(as.data.frame(go_clusterprof), "pathway_enrichment/go_enrichment_batch8_9_patients_vs_controls.xlsx")
```

# Enquire GSEA gene sets
```{r, eval=FALSE}
msigdbr::msigdbr_species()
msigdbr_list <- msigdbr(species = "Homo sapiens")

msigdbr_list |> 
  distinct(gs_collection, gs_subcollection) |> 
  arrange(gs_collection, gs_subcollection) |> 
  View()
```

# GSEA function
```{r}
run_multi_gsea <- function(dge_df,
                           sets = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                                    "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
                           output_prefix = "pathway_enrichment",
                           species = "Homo sapiens") {
  
  suppressPackageStartupMessages({
    library(msigdbr)
    library(clusterProfiler)
    library(tidyverse)
    library(openxlsx)
    library(ggplot2)
    library(patchwork)
    library(enrichplot)
  })

  gene_sets <- lapply(setNames(sets, sets), function(x){
    msigdbr(species = species, subcollection = x)
  })
  
  # Filtering genes for those present in DESeq results
  gene_sets <- lapply(gene_sets, function(sets){
    sets[sets$gene_symbol %in% dge_df$gene_names, ]
  })

  filtered_df <- dge_df |> 
    filter(!is.na(log2FoldChange), !is.na(padj)) |>
    arrange(desc(abs(log2FoldChange))) |> 
    distinct(gene_names, .keep_all = TRUE)

  # Replacing padj = 0
  filtered_df <- filtered_df |> 
    mutate(padj = ifelse(padj == 0, .Machine$double.xmin, padj))

  # Ranking metric: sign(LFC) x –log10(padj)
  ranking_vector <- sign(filtered_df$log2FoldChange) * -log10(filtered_df$padj)
  names(ranking_vector) <- filtered_df$gene_names
  ranking_vector <- ranking_vector[is.finite(ranking_vector)]
  ranking_vector <- sort(ranking_vector, decreasing = TRUE)
  # Adding tiny jitter only if ties are present
  if (any(duplicated(ranking_vector))) {
    ranking_vector <- ranking_vector + rnorm(length(ranking_vector), 0, 1e-8)
    ranking_vector <- sort(ranking_vector, decreasing = TRUE)
  }

  gsea_results <- lapply(names(gene_sets), function(set_name){
    message(paste0("Running: ", set_name))
    
    gs_df <- gene_sets[[set_name]]
    
    gsea_res <- GSEA(
        geneList = ranking_vector,
        TERM2GENE = gs_df |> select(gs_name, gene_symbol),
        minGSSize = 10,
        maxGSSize = 500,
        pvalueCutoff = 0.05,
        pAdjustMethod = "BH",
        eps = 0,
        nPermSimple = 10000,
        seed = TRUE
      )
    
    if (is.null(gsea_res) || nrow(gsea_res@result) == 0) {
      message(paste0("No significant pathways in ", set_name))
      return(NULL)
    }
    
    df <- gsea_res@result |> arrange(p.adjust)
    df$Description <- stringr::str_trunc(df$Description, width = 50)
    # Top pathway
    top_path <- df$ID[1]
    
    # Bubble plot
    if (nrow(df) >= 1) {
      p1 <- df |> 
        slice(1:min(20, nrow(df))) |>
        ggplot(aes(x = NES, y = reorder(Description, NES),
                   size = setSize, fill = p.adjust)) +
        geom_point(shape = 21) +
        theme_minimal() +
        scale_fill_viridis_c(trans = "log10") +
        ggtitle(paste0(set_name, " — Bubble Plot")) +
        xlab("NES") + ylab("")
      
      ggsave(
        paste0(output_prefix, "/GSEA_", gsub(":", "_", set_name), "_bubble.png"),
        p1, width = 10, height = 6
      )
    }
    
    # Running score plot
    p2 <- gseaplot2(
      gsea_res, geneSetID = top_path,
      title = paste0(set_name, ": ", df$Description[1])
    )
    
    ggsave(
      paste0(output_prefix, "/GSEA_", gsub(":", "_", set_name), "_running_score.png"),
      p2, width = 8, height = 6
    )
    
    return(gsea_res@result)
  })
  
  names(gsea_results) <- gsub(":", "_", sets)
  write.xlsx(gsea_results, paste0(output_prefix, "/GSEA_results.xlsx"))
  
  return(gsea_results)
}
```

# Running GSEA for batch 8 and 9 DGE results
```{r, eval=FALSE}
gsea_batch8_9 <- run_multi_gsea(dge_df = dge_batch_8_9,
                                 sets = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                                          "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
                                 output_prefix = "pathway_enrichment",
                                 species = "Homo sapiens")
```

# GSVA function
```{r}
run_gsva_pipeline <- function(
  vst_object,
  msigdb_list = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                  "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
  output_excel = "GSVA_results.xlsx",
  output_dir = "pathway_enrichment",
  assay_name = "counts",
  kcdf_mode = "Gaussian"
) {

  suppressPackageStartupMessages({
    library(GSVA)
    library(SummarizedExperiment)
    library(msigdbr)
    library(limma)
    library(sva)
    library(ComplexHeatmap)
    library(circlize)
    library(RColorBrewer)
    library(openxlsx)
    library(tidyverse)
    library(grid)
  })

  # ensure output dir
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

  wb <- createWorkbook()

  message("Available columns in colData(vst_object):")
  print(colnames(colData(vst_object)))

  ## Ask user for design (variables used to build model)
  design_vars <- readline(prompt =
    "Enter variables for the design matrix (e.g. 'Batch + Sex + Age + Condition'): ")
  design_formula <- as.formula(paste0("~ ", design_vars))

  ## Ask user for annotation column (for heatmap)
  annot_col <- readline(prompt =
    "Enter the column name in colData(vst_object) to color in the heatmap (e.g. 'Condition'): ")
  if (!(annot_col %in% colnames(colData(vst_object)))) {
    stop("Annotation column not found in colData(vst_object). Aborting.")
  }
  annot_values <- unique(as.character(colData(vst_object)[[annot_col]]))
  message("Annotation groups detected:")
  print(annot_values)

  ## Ask user for annotation colors (produce named character vector)
  annot_colors <- character(length(annot_values))
  names(annot_colors) <- annot_values
  for (val in annot_values) {
    col_in <- readline(prompt = paste0("Enter color for group '", val,
                                       "' (e.g. 'salmon' or 'lightgreen') [press Enter to default 'grey']: "))
    if (col_in == "") col_in <- "grey"
    annot_colors[val] <- col_in
  }

  ## Build model matrices once from vst_object
  mod <- model.matrix(design_formula, colData(vst_object))
  mod0 <- model.matrix(~1, colData(vst_object))

  message("Available coefficients from the model (will be tested):")
  print(colnames(mod))
  coef_user <- readline(prompt = "Enter coefficient to test (exact column name, e.g. 'ConditionPatient'): ")
  if (!(coef_user %in% colnames(mod))) {
    hits <- grep(coef_user, colnames(mod), value = TRUE)
    if (length(hits) == 0) stop("Coefficient not found in model columns. Aborting.")
    message("Your input matched the following column(s): ", paste(hits, collapse = ", "))
    coef_user <- hits[1]
  }

  ## color scale for heatmap rows
  pwyexpcol <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
  pwyexpcol <- rev(pwyexpcol)

  results_list <- list()

  for (collection in msigdb_list) {
    message("\nProcessing collection: ", collection, "\n")

    # cleaned name for files
    collection_clean <- gsub("[^A-Za-z0-9_]", "_", collection)
    collection_clean <- substr(collection_clean, 1, 31)

    msig_df <- tryCatch(
      msigdbr(species = "Homo sapiens", subcollection = collection),
      error = function(e1) tryCatch(msigdbr(species = "Homo sapiens", subcollection = collection),
                                   error = function(e2) NULL)
    )
    if (is.null(msig_df) || nrow(msig_df) == 0) {
      warning("msigdbr could not find collection '", collection, "'. Skipping.")
      next
    }

    gene_sets_list <- split(msig_df$gene_symbol, msig_df$gs_name)
    gene_sets_list <- lapply(gene_sets_list, function(pathway) intersect(pathway, rownames(vst_object)))
    gene_sets_list <- gene_sets_list[sapply(gene_sets_list, length) >= 1] # drop empty gene-sets

    if (length(gene_sets_list) == 0) {
      warning("No overlapping gene sets between collection '", collection, "' and vst_object. Skipping.")
      next
    }

    ## GSVA
    gsvapar <- gsvaParam(
      vst_object,
      geneSets = gene_sets_list,
      assay = assay_name,
      kcdf = kcdf_mode,
      maxDiff = TRUE,
      absRanking = FALSE
    )

    es <- gsva(gsvapar)

    ## Save GSVA full matrix to workbook sheet
    gsva_df <- as.data.frame(assay(es)) |> rownames_to_column("Pathway")
    addWorksheet(wb, sheetName = collection_clean)
    writeData(wb, sheet = collection_clean, gsva_df)

    ## copy global model matrix and use locally
    mod_local <- mod
    mod0_local <- mod0

    ## SVA (estimate surrogate variables from GSVA scores) to estimate sample-level heterogeneity
    sv <- sva(assay(es), mod_local, mod0_local)
    mod_local <- cbind(mod_local, sv$sv)

    ## Fit limma
    fit <- lmFit(assay(es), mod_local)
    fit.eb <- eBayes(fit, robust = TRUE)
    gssizes <- geneSetSizes(es)
    fit.eb.trend <- eBayes(fit.eb, robust = TRUE, trend = gssizes)

    tt <- topTable(fit.eb.trend, coef = coef_user, n = Inf)
    DEpwys <- rownames(tt)[!is.na(tt$adj.P.Val) & tt$adj.P.Val <= 0.05]

    if (length(DEpwys) == 0) {
      message("No DE pathways found (FDR <= 0.05) for collection: ", collection)
      results_list[[collection_clean]] <- list(GSVA_matrix = assay(es), DE_table = tt, DE_matrix = NULL)
      next
    }

    message("Found ", length(DEpwys), " DE pathways for collection: ", collection)

    ## find condition columns in mod_local
    cond_cols <- which(colnames(mod_local) == coef_user)
    if (length(cond_cols) == 0) {
      ## try to infer variable name (e.g., ConditionPatient -> Condition)
      var_hint <- sub("([A-Za-z0-9_.-]+).*", "\\1", coef_user)
      cond_cols <- grep(paste0("^", var_hint), colnames(mod_local))
    }
    if (length(cond_cols) == 0) stop("Cannot determine condition column(s) for coef: ", coef_user)

    # covariates: drop intercept (col 1) and condition columns
    all_cols <- seq_len(ncol(mod_local))
    covar_cols <- setdiff(all_cols, c(1, cond_cols))
    if (length(covar_cols) == 0) covar_mat <- NULL else covar_mat <- mod_local[, covar_cols, drop = FALSE]

    # Remove covariates effect for plotting
    DEpwys_es_all <- removeBatchEffect(
      assay(es[DEpwys, , drop = FALSE]),
      covariates = covar_mat,
      design = mod_local[, cond_cols, drop = FALSE]
    )

    # Select top 30 pathways by adj.P.Val
    top_n <- min(30, nrow(DEpwys_es_all))
    top_idx <- order(tt[DEpwys, "adj.P.Val"])[1:top_n]
    DEpwys_es <- DEpwys_es_all[top_idx, , drop = FALSE]

    # Truncate pathway names
    rownames(DEpwys_es) <- stringr::str_trunc(rownames(DEpwys_es), width = 50)

    # cluster pathways
    gsetClust <- hclust(as.dist(1 - cor(t(DEpwys_es), method = "pearson")), method = "complete")

    # prepare annotation (use vst_object metadata)
    sample_annot <- as.character(colData(vst_object)[[annot_col]])
    names(sample_annot) <- colnames(es) # ensure names match columns in DEpwys_es

    ann <- HeatmapAnnotation(
      Annotation = sample_annot,
      col = list(Annotation = annot_colors),
      show_annotation_name = FALSE,
      show_legend = FALSE
    )

    # truncate long pathway names for display (optional)
    rownames(DEpwys_es) <- stringr::str_trunc(rownames(DEpwys_es), width = 50)

    # Save heatmap (PNG)
    out_png <- file.path(output_dir, paste0("GSVA_DEpws_", collection_clean, "_heatmap.png"))
    png(out_png, width = 4500, height = 2000, res = 300)

    ht <- Heatmap(
      DEpwys_es,
      name = "GSVA Enrichment Score",
      col = pwyexpcol,
      cluster_rows = gsetClust,
      show_row_names = TRUE,
      row_names_gp = gpar(fontsize = 8),  
      column_names_gp = gpar(fontsize = 8),
      cluster_columns = FALSE,
      show_column_names = TRUE,
      top_annotation = ann,
      show_heatmap_legend = FALSE
    )

    gsva_enrichment_legend <- Legend(
      title = "GSVA Enrichment Score",
      col_fun = colorRamp2(
        breaks = c(-max(abs(DEpwys_es)), 0, max(abs(DEpwys_es))),
        colors = pwyexpcol[c(1, 128, 256)]
      ),
      at = seq(-max(abs(DEpwys_es)), max(abs(DEpwys_es)), length.out = 5),
      labels = round(seq(-max(abs(DEpwys_es)), max(abs(DEpwys_es)), length.out = 5), 2),
      title_gp = gpar(fontsize = 8, fontface = "bold"),
      labels_gp = gpar(fontsize = 5)
    )

    condition_legend <- Legend(
      labels = names(annot_colors),
      title = annot_col,
      legend_gp = gpar(fill = annot_colors),
      title_gp = gpar(fontsize = 8, fontface = "bold"),
      labels_gp = gpar(fontsize = 8)
    )

    combine_legends <- packLegend(gsva_enrichment_legend, condition_legend, direction = "vertical")

    draw(ht, heatmap_legend_side = "left", annotation_legend_side = "left", 
         heatmap_legend_list = combine_legends, padding = unit(c(5, 5, 5, 35), "mm")) #  bottom, left, top, right,
    dev.off()

    results_list[[collection_clean]] <- list(GSVA_matrix = assay(es), DE_table = tt, DE_matrix = DEpwys_es)

    message("Saved heatmap: ", out_png)
  }

  # save workbook inside output_dir
  out_wb <- file.path(output_dir, output_excel)
  saveWorkbook(wb, out_wb, overwrite = TRUE)
  message("Saved combined GSVA workbook: ", out_wb)

  message("GSVA pipeline finished. Returning results as a list.")
  return(invisible(results_list))
}
```

# Running GSVA for batch 8 and 9 DGE results
```{r, eval=FALSE}
dds_batch8_9 <- readRDS("dds_batch8_9.rds")
vst_batch8_9 <- DESeq2::vst(dds_batch8_9, blind = FALSE)
SummarizedExperiment::assayNames(vst_batch8_9) <- "counts"

gsva_batch8_9 <- run_gsva_pipeline(
  vst_object = vst_batch8_9,
  msigdb_list = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                  "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
  output_excel = "GSVA_results.xlsx",
  output_dir = "pathway_enrichment",
  assay_name = "counts",
  kcdf_mode = "Gaussian"
)
```

# DE among patients of batches 8, 9 with (1) and without HCM (0)
```{r, eval=FALSE}
metadata_frda_batch8_9_patients <- metadata_frda_batch8_9 |> filter(Condition == "Patient")
metadata_frda_batch8_9_patients$Condition <- droplevels(metadata_frda_batch8_9_patients$Condition)
count_data_frda_batch8_9_patients <- count_data_filtered[, rownames(metadata_frda_batch8_9_patients)]

hcm_batch8_9_patients_result <- dge(counts = count_data_frda_batch8_9_patients,
                            meta = metadata_frda_batch8_9_patients,
                            design = ~ Batch + Sex + Age + HCM,
                            filename = "res/res_batch8_9_hcm_vs_non_hcm.xlsx",
                            filename_volcano = "volcano_plot/volcano_batch8_9_hcm_vs_non_hcm.jpeg")
  ```

# WGCNA
```{r, eval=FALSE}
allowWGCNAThreads()

dds_batch8_9_wgcna <- DESeqDataSetFromMatrix(countData = round(count_data_frda_batch8_9),
                                colData = metadata_frda_batch8_9, design = ~ 1)
vst_batch8_9_wgcna <- vst(dds_batch8_9_wgcna)
expr_vst_batch8_9_wgcna <- assay(vst_batch8_9_wgcna)
expr_rb_batch8_9_wgcna <- removeBatchEffect(expr_vst_batch8_9_wgcna, batch = metadata_frda_batch8_9$Batch,
                                           covariates = model.matrix(~ Sex + Age, data = metadata_frda_batch8_9)[, -1],
                                           design = NULL)

# Identifying genes and samples with excessive number of missing values
gsg <- goodSamplesGenes(t(expr_rb_batch8_9_wgcna), verbose = 3)
gsg$allOK

if (!gsg$allOK) {
  if (sum(!gsg$goodGenes) > 0)
    printFlush(paste("Removing genes:", paste(colnames(t(expr_rb_batch8_9_wgcna))[!gsg$goodGenes], collapse = ", ")))
  if (sum(!gsg$goodSamples) > 0)
    printFlush(paste("Removing samples:", paste(rownames(t(expr_rb_batch8_9_wgcna))[!gsg$goodSamples], collapse = ", ")))
  expr_rb_batch8_9_wgcna <- expr_rb_batch8_9_wgcna[gsg$goodGenes, gsg$goodSamples]
  metadata_frda_batch8_9_wgcna <- metadata_frda_batch8_9[gsg$goodSamples, ]
}

# Clustering samples by Euclidean distance to detect outlier samples
sample_tree <- hclust(dist(t(expr_rb_batch8_9_wgcna)), method = "average")
plot(sample_tree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
# abline(h = 130, col = "red") # adjust height threshold as needed
dev.copy(png, filename = "wgcna/wgcna_sample_clustering_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Determine cluster under the line
# clust <- cutreeStatic(sample_tree, cutHeight = 200, minSize = 10)
# table(clust)
# clust 1 contains the samples we want to keep.
# keepSamples = (clust==1)

# Remove outlier sample FA102
outlier_sample <- "FA102"
expr_rb_batch8_9_wgcna <- expr_rb_batch8_9_wgcna[, colnames(expr_rb_batch8_9_wgcna) != outlier_sample]
metadata_frda_batch8_9_wgcna <- metadata_frda_batch8_9_wgcna[rownames(metadata_frda_batch8_9_wgcna) != outlier_sample, ]

# Recluster samples after removing outlier
sample_tree <- hclust(dist(t(expr_rb_batch8_9_wgcna)), method = "average")
plot(sample_tree, main = "Sample clustering after outlier removal", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
dev.copy(png, filename = "wgcna/wgcna_sample_clustering_batch8_9_outlier_removed.png", width = 2000, height = 1500, res = 150)
dev.off()

# Automatic network construction and module detection
norm_count_data <- t(expr_rb_batch8_9_wgcna)

# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))

# Call the network topology analysis function
sft <- pickSoftThreshold(norm_count_data,
                  powerVector = power,
                  networkType = "signed",
                  verbose = 5)

sft.data <- sft$fitIndices

# visualization to pick power
# ideal power should have signed R^2 > 0.9 and minimal mean connectivity
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_text() +
  geom_hline(yintercept = 0.8, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()

a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_text() +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()
  
grid.arrange(a1, a2, nrow = 2)
dev.copy(png, filename = "wgcna/wgcna_soft_thresholding_power_selection_batch8_9.png", width = 2000, height = 2500, res = 150)
dev.off()

soft_power <- 6
temp_cor <- cor # store original cor function to temporarily override
cor <- WGCNA::cor

bwnet <- blockwiseModules(norm_count_data,
                 maxBlockSize = 14000,
                 minModuleSize = 30,
                 TOMType = "signed",
                 power = soft_power,
                 mergeCutHeight = 0.25,
                 numericLabels = FALSE,
                 saveTOMs = TRUE,
                 saveTOMFileBase = "wgcna/batch8_9_wgcna_TOM",
                 randomSeed = 1234,
                 verbose = 3)

saveRDS(bwnet, file = "wgcna/wgcna_frda_batch8_9.rds")
bwnet <- readRDS("wgcna/wgcna_frda_batch8_9.rds")

cor <- temp_cor

module_eigengenes <- bwnet$MEs
table(bwnet$colors)

# Plot the dendrogram and the module colors underneath for block 1
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors[bwnet$blockGenes[[1]]], bwnet$colors[bwnet$blockGenes[[1]]]),
                    c("unmerged", "merged"),
                    main = "Gene dendogram and module colours in block 1",
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
dev.copy(png, filename = "wgcna/wgcna_gene_dendrogram_block1_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Plot the dendrogram and the module colors underneath for block 2
plotDendroAndColors(bwnet$dendrograms[[2]], cbind(bwnet$unmergedColors[bwnet$blockGenes[[2]]], bwnet$colors[bwnet$blockGenes[[2]]]),
                    c("unmerged", "merged"),
                    main = "Gene dendogram and module colours in block 2",
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
dev.copy(png, filename = "wgcna/wgcna_gene_dendrogram_block2_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Relate modules to external traits
metadata_frda_batch8_9_wgcna$condition_categorize <- ifelse(metadata_frda_batch8_9_wgcna$Condition == "Control", 0, 1)
metadata_frda_batch8_9_wgcna$sex_categorize <- ifelse(metadata_frda_batch8_9_wgcna$Sex == "F", 0, 1)

col_to_fill_zero <- c("HCM", "Diabetes", "mFARS total", "mFARS USS", "FSA scale")
metadata_frda_batch8_9_wgcna[col_to_fill_zero] <- lapply(metadata_frda_batch8_9_wgcna[col_to_fill_zero], function(x) {
  x[is.na(x)] <- 0
  return(x)
})

col_to_num_convert <- c("HCM", "Diabetes", "mFARS total", "mFARS USS", "FSA scale")
metadata_frda_batch8_9_wgcna[col_to_num_convert] <- lapply(metadata_frda_batch8_9_wgcna[col_to_num_convert], function(x) {
  as.numeric(as.character(x))
})

trait_data <- metadata_frda_batch8_9_wgcna |> 
  select(condition_categorize, HCM, Diabetes, Age, sex_categorize, GAA1, GAA2, `FSA scale`,  `mFARS total`, `mFARS USS`)

nSamples <- nrow(norm_count_data)
nGenes <- ncol(norm_count_data)

module_trait_cor <- cor(module_eigengenes, trait_data, use = "p", method = "pearson")
module_trait_pvalue <- corPvalueStudent(module_trait_cor, nSamples)

# Heatmap of module-trait relationships
heatmap.data <- merge(module_eigengenes, trait_data, by = 'row.names')
heatmap.data <- heatmap.data |> 
  column_to_rownames(var = 'Row.names')

module_eigengenes_length <- ncol(module_eigengenes)
trait_data_length <- ncol(trait_data)

CorLevelPlot(heatmap.data,
             x = names(heatmap.data)[module_eigengenes_length + 1:trait_data_length],
             y = names(heatmap.data)[1:module_eigengenes_length],
             col = c("green", "lightgreen", "white", "pink", "red"))
dev.copy(png, filename = "wgcna/wgcna_module_trait_relationships_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Extract genes in significant modules
significant_modules <- module_trait_pvalue |> 
  as.data.frame() |> 
  rownames_to_column(var = "Module") |> 
  pivot_longer(-Module, names_to = "Trait", values_to = "pvalue") |> 
  filter(pvalue < 0.01) |> 
  pull(Module) |> 
  unique()

output_list <- list()

for (mod in significant_modules) {
  mod_color <- sub("ME", "", mod) |> tolower()
  genes_in_module <- names(bwnet$colors)[bwnet$colors == mod_color]
  
  output_list[[mod]] <- data.frame(Gene = genes_in_module)
}

write_xlsx(output_list, "wgcna/genes_in_significant_modules_batch8_9.xlsx")

# Enrichment analysis for genes in significant modules
go_enrichment <- list()

GO_enrichment_results <- list()
for (mod in significant_modules) {
  genes_in_module <- output_list[[mod]]$Gene
  
  go_enrich <- enrichGO(gene = genes_in_module,
                        OrgDb = org.Hs.eg.db,
                        keyType = "SYMBOL",
                        ont = "ALL",
                        pAdjustMethod = "BH",
                        pvalueCutoff = 0.05,
                        qvalueCutoff = 0.05)
  
  GO_enrichment_results[[mod]] <- go_enrich
  
  p <- dotplot(go_enrich, showCategory = 20) +
    ggtitle(paste0("GO Enrichment for Module ", mod))
  
  ggsave(paste0("wgcna/GO_enrichment_module_", mod, "_batch8_9.png"),
         plot = p,
         width = 10,
         height = 6,
         dpi = 300)
}

write.xlsx(GO_enrichment_results, "wgcna/go_enrichment_significant_modules_batch8_9.xlsx")
```