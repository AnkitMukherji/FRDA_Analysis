---
title: "RNA-seq FRDA Analysis Pipeline"
author: "Ankit Mukherjee"
format: html
---

# Load Libraries
```{r}
library(DESeq2)
library(limma)
library(sva)
library(tidyverse)
library(stringr)
library(readxl)
library(writexl)
library(openxlsx)
library(biomaRt)
library(annotables)
library(org.Hs.eg.db)
library(EnsDb.Hsapiens.v86)
library(ggplot2)
library(BiocParallel)
library(patchwork)
library(ggrepel)
library(GSEABase)
library(Biobase)
library(GSVA)
library(gprofiler2)
library(clusterProfiler)
library(enrichR)
library(msigdbr)
library(enrichplot)
library(org.Hs.eg.db)
library(ComplexHeatmap)
library(WGCNA)
library(rstatix)
library(gridExtra)
library(CorLevelPlot)
library(RColorBrewer)
library(ggpubr)
library(caret)
library(pROC)
```

# Load RDS Files
```{r}
rds_files <- list.files(path = "salmon/", pattern = "\\.rds$", full.names = TRUE)
rds_list <- lapply(rds_files, readRDS)
names(rds_list) <- basename(rds_files)
```

# Load & Prepare Metadata
```{r}
attributes_frda <- read_xlsx("Metadata_RNAseq_FAvsHC.xlsx") |> subset(select = -Sno)
severity_scoring_frda <- read_xlsx("severity scoring.xlsx")
metadata_frda <- merge(attributes_frda, severity_scoring_frda, by = "Raw Data ID", all.x = TRUE)

metadata_frda$Batch <- factor(as.numeric(metadata_frda$Batch))
metadata_frda$Sex <- factor(metadata_frda$Sex)
metadata_frda$Age_scaled <- scale(as.numeric(metadata_frda$Age))
metadata_frda$Condition <- factor(metadata_frda$Condition, levels = c("Control", "Patient"))
metadata_frda$FSA_scaled <- scale(as.numeric(metadata_frda$`FSA scale`))
metadata_frda$mFARS_scaled <- scale(as.numeric(metadata_frda$`mFARS total`))
metadata_frda$mFARS_USS_scaled <- scale(as.numeric(metadata_frda$`mFARS USS`))
metadata_frda$DD_scaled <- scale(as.numeric(metadata_frda$DD))
metadata_frda$Onset_scaled <- scale(as.numeric(metadata_frda$Onset))
metadata_frda$HCM <- factor(as.numeric(metadata_frda$HCM), levels = c(0, 1))
metadata_frda$Diabetes <- factor(as.numeric(metadata_frda$Diabetes), levels = c(0, 1))
metadata_frda$GAA1_scaled <- scale(as.numeric(metadata_frda$GAA1))
metadata_frda$GAA2_scaled <- scale(as.numeric(metadata_frda$GAA2))

rownames(metadata_frda) <- metadata_frda$`Raw Data ID`
metadata_frda <- subset(metadata_frda, select = -`Raw Data ID`)
metadata_frda[metadata_frda == "NA"] <- NA

# Adding a separate column in metadata based on library prep method
metadata_frda <- metadata_frda |> 
  mutate(Library_Prep = case_when(
    Batch %in% c(1, 2, 3, 4, 5, 6, 7) ~ "mRNA",
    Batch %in% c(8, 9) ~ "totalRNA"
  ))

# Matching the rownames of all except the first to the first
all(sapply(rds_list[-1], function(x) identical(rownames(assay(x)), rownames(assay(rds_list[[1]])))))
```

# Clean Sample Sets
```{r}
# Removing batch3 top up samples from batch3
samples_to_remove <- intersect(colnames(assay(rds_list[[3]])), colnames(assay(rds_list[[4]])))
rds_list[[3]] <- rds_list[[3]][, !colnames(assay(rds_list[[3]])) %in% samples_to_remove]

# Remove PC samples in Batch8
rds_list[[9]] <- rds_list[[9]][, !colnames(assay(rds_list[[9]])) %in% c("PC1", "PC2", "PC3")]
```

# Combine Count Data
```{r}
combined_rds <- do.call(cbind, rds_list)
count_data <- assay(combined_rds)
count_data <- count_data[, sort(colnames(count_data))]

if (FALSE) {
  # Convert Ensembl IDs to Gene Names
  # Understanding Ensembl ID format: e.g., ENSMUSG00000000017167.6
  # ENS <- Ensembl IDs start with ENS
  # Species <- Mus musculus (MUS), for human there is no species code
  # Object type <- Exon (E), Protein Family (FM), Gene (G), Gene Tree (GT), Protein (P), Regulatory Feature (R), Transcript (T)
  # Identifier <- Unique number assigned to each object
  # Version <-  Specifies the number of times the model has changed during its time in Ensembl
  ensembl_ids <- rownames(count_data)
  ensembl_ids_clean <- sub("\\.\\d+$", "", ensembl_ids) # Remove version numbers
  # Using biomaRt
  listEnsembl()
  ensembl <- useEnsembl(biomart = "genes")
  datasets <- listDatasets(ensembl)
  ensembl.con <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  attr <- listAttributes(ensembl.con)
  filters <- listFilters(ensembl.con)
  gene_map <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                    filters = "ensembl_gene_id",
                    values = ensembl_ids_clean,
                    mart = ensembl.con)
  # Using annotables
  grch38 |> filter(ensgene %in% ensembl_ids_clean) |> 
    select(ensgene, symbol) |> 
    View()

  # Using annotation DBs
  keytypes(org.Hs.eg.db)
  columns(org.Hs.eg.db)
  mapIds(org.Hs.eg.db,
        keys = ensembl_ids_clean,
        column = "SYMBOL",
        keytype = "ENSEMBL",
        multiVals = "first")

  keytypes(EnsDb.Hsapiens.v86)
  columns(EnsDb.Hsapiens.v86)
  mapIds(EnsDb.Hsapiens.v86,
        keys = ensembl_ids_clean,
        column = "GENENAME",
        keytype = "GENEID",
        multiVals = "first")
}

# Replace Ensembl IDs with gene names
gene_names <- rowData(rds_list[[1]])$gene_name
rownames(count_data) <- make.unique(gene_names)

# Filter low-expression genes and remove genes with no annotation
dim(count_data)
count_data_filtered <- count_data[(rowSums(count_data >= 10) >= 5) & (!grepl("^ENSG", rownames(count_data))), ]
dim(count_data_filtered)
```

# Check Design Matrix
```{r}
# Check whether the model matrix is full rank or not 
# (i.e. there are no collinearities between covariates in the design formula)
check_design_collinearity <- function(formula, data) {
  design_matrix <- model.matrix(formula, data = data)
  # Check rank
  is_full_rank <- qr(design_matrix)$rank == ncol(design_matrix) # QR decomposition to check rank
  cat("Design matrix full rank: ", is_full_rank, "\n")
  if (!is_full_rank) {
    cat("\nDetected linear dependencies:\n")
    lm_obj <- lm(rep(1, nrow(design_matrix)) ~ design_matrix) # Fit linear model to identify dependencies
    print(alias(lm_obj)) # Display linear dependencies
  } else {
    cat("No linear dependencies detected.\n")
  }
  invisible(design_matrix)
}
```

# Differential expression between patients and controls from all batches
```{r, eval=FALSE}
all.equal(rownames(metadata_frda), colnames(count_data_filtered))
# dds <- DESeqDataSetFromMatrix(countData = round(count_data_filtered), 
#                               colData = metadata_frda, 
#                               design = ~ Batch + Sex + Age_scaled + Condition)
# dds <- estimateSizeFactors(dds)
# dds <- DESeq(dds, parallel = TRUE)
# saveRDS(dds, "dds_frda.rds")
dds <- readRDS("dds_frda.rds")
```

# Batch Correction
```{r, eval=FALSE}
vsd <- vst(dds, blind = FALSE)
expr_vst <- assay(vsd)
covs <- model.matrix(~ Sex + Age + Condition, data = metadata_frda)
expr_rb <- limma::removeBatchEffect(expr_vst, batch = metadata_frda$Batch, design = covs)
```

# PCA Plot Function
```{r}
# PCA plot before and after removing batch effects with top 500 variable genes
# plotPCA(vsd, intgroup = c("Batch", "Condition")) # before batch effect removal
# or
plot_pca <- function(expr_matrix, metadata, top_n = 500, color_by, shape_by, title) {
  expr_matrix <- as.matrix(expr_matrix)
  metadata <- metadata[colnames(expr_matrix), , drop = FALSE]
  topVarGenes <- order(matrixStats::rowVars(expr_matrix), decreasing = TRUE)[seq_len(top_n)]
  
  pca_res <- prcomp(t(expr_matrix[topVarGenes, ]))
  percent_var <- pca_res$sdev^2 / sum(pca_res$sdev^2)
  
  pca_data <- data.frame(
    Sample = colnames(expr_matrix),
    PC1 = pca_res$x[, 1],
    PC2 = pca_res$x[, 2],
    Color = metadata[[color_by]]
  )
  
  if (!is.null(shape_by)) {
    pca_data$Shape <- metadata[[shape_by]]
  }
  
  pca_data <- na.omit(pca_data)
  
  p <- ggplot(pca_data, aes(x = PC1, y = PC2)) +
    geom_point(
      aes(color = Color, shape = if (!is.null(shape_by)) Shape else NULL),
      size = 3, alpha = 0.8
    ) +
    theme_bw(base_size = 14) +
    labs(
      title = title,
      x = paste0("PC1: ", round(percent_var[1] * 100, 1), "% variance"),
      y = paste0("PC2: ", round(percent_var[2] * 100, 1), "% variance"),
      color = color_by,
      shape = shape_by
    ) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "right"
    )
  
  return(p)
}
```

# DGE
```{r, eval=FALSE}
# coef from resultsNames(dds)
# res_contrast <- results(dds, contrast = c("Condition", "Patient", "Control")) |> 
#   as.data.frame() |> 
#   rownames_to_column("gene_names")

# res <- lfcShrink(dds, coef = "Condition_Patient_vs_Control", type = "apeglm", parallel = TRUE) |> 
#   as.data.frame() |> 
#   rownames_to_column("gene_names")
# saveRDS(res, "res_frda.rds")
res <- readRDS("res_frda.rds")
```

# Volcano Plot Function
```{r}
volcano_plot <- function(res,
                         gene_label_col,
                         lfc_threshold = 2,
                         padj_threshold = 0.01,
                         top_n = 10,
                         base_size = 14) {

  vol_data <- res |>
    na.omit() |> 
    mutate(Expression = case_when(
      log2FoldChange >= lfc_threshold & padj <= padj_threshold ~ "Upregulated",
      log2FoldChange <= -lfc_threshold & padj <= padj_threshold ~ "Downregulated",
      TRUE ~ "Not significant"
    ))

  top_up <- vol_data |>
    filter(Expression == "Upregulated") |>
    arrange(padj) |>
    head(top_n)
  
  top_down <- vol_data |>
    filter(Expression == "Downregulated") |>
    arrange(padj) |>
    head(top_n)
  
  top_genes <- bind_rows(top_up, top_down)

  p <- ggplot(vol_data, aes(x = log2FoldChange, y = -log10(padj))) +
    geom_point(aes(color = Expression)) +
    geom_text_repel(
      data = top_genes,
      aes(label = .data[[gene_label_col]]),
      size = 4,
      max.overlaps = 15
    ) +
    scale_color_manual(values = c(
      "Upregulated" = "#D55E00",
      "Downregulated" = "#0072B2",
      "Not significant" = "gray70"
    )) +
    scale_x_continuous(name = "Log2 fold change") +
    scale_y_continuous(name = "-Log10 adjusted p-value") +
    geom_hline(yintercept = -log10(padj_threshold), linetype = 2, color = "black") +
    geom_vline(xintercept = c(-lfc_threshold, lfc_threshold), linetype = 2, color = "black") +
    theme_classic(base_size = base_size) +
    theme(
      panel.grid = element_blank(),
      plot.background = element_rect(fill = "white"),
      legend.position = "right"
    )
  
  return(p)
}
```

# Comparing FXN expression levels across patients and controls
```{r, eval=FALSE}
fxn_rb <- expr_rb["FXN", ]
fxn_df_pre <- count_data["FXN", ] |> 
              rownames_to_column("Gene") |> 
              pivot_longer(cols = -Gene, names_to = "SampleID", values_to = "fxn_pre") |> 
              select(-Gene)
fxn_df_post <- fxn_rb |> as.data.frame() |> rownames_to_column("SampleID")
write_xlsx(fxn_df_pre, "fxn_df_pre.xlsx")
write_xlsx(fxn_df_post, "fxn_exp.xlsx")

data_fxn <- metadata_frda
data_fxn$FXN_expression <- fxn_rb
data_fxn <- data_fxn[order(data_fxn$FXN_expression), ]
data_fxn <- data_fxn |> rownames_to_column("SampleID")
highlight_samples <- c("FA18", "FA25", "FA43", "FA45")
data_fxn$highlight <- ifelse(data_fxn$SampleID %in% highlight_samples, "Highlight", "Other")

fxn_exp <- ggplot(data_fxn, aes(x = reorder(SampleID, FXN_expression),
                      y = FXN_expression)) +
  geom_point(aes(color = Condition, alpha = highlight, size = highlight)) +
  scale_alpha_manual(values = c("Other" = 0.5, "Highlight" = 1)) +
  scale_size_manual(values = c("Other" = 2, "Highlight" = 4)) +
  geom_text(data = subset(data_fxn, highlight == "Highlight"),
            aes(label = SampleID),
            vjust = -1.0, size = 3, color = "black", fontface = "bold") +
  theme_bw(base_size = 14) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Samples", y = "FXN expression")

ggsave("fxn_exp.jpeg",
        plot = fxn_exp, 
        device = "jpeg",
        units = "in",
        height = 8,
        width = 25,
        dpi = 600)
```

# Segregating samples on the basis of batch effects into test and replication cohort

```{r, eval=FALSE}
# Removing samples FA18, HC8, FA43, FA25, FA81, FA45 and FA82 (from FXN exp plot)
samples_to_remove_fxn_abnormal <- c("FA18", "HC8", "FA43", "FA25", "FA81", "FA45", "FA82")
metadata_frda_remove_fxn_abnormal <- metadata_frda[!rownames(metadata_frda) %in% samples_to_remove_fxn_abnormal, ]
count_data_remove_fxn_abnormal <- count_data_filtered[, rownames(metadata_frda_remove_fxn_abnormal)]

pca_data <- plotPCA(vsd, intgroup = c("Batch", "Condition"), returnData = TRUE)
test_batches <- pca_data$Batch[pca_data$PC1 < 0] |> unique()
replication_batches <- pca_data$Batch[pca_data$PC1 > 0] |> unique()

test_metadata <- metadata_frda_remove_fxn_abnormal[metadata_frda_remove_fxn_abnormal$Batch %in% test_batches, ]
test_count_data <- count_data_filtered[, rownames(test_metadata)]
replication_metadata <- metadata_frda_remove_fxn_abnormal[metadata_frda_remove_fxn_abnormal$Batch %in% replication_batches, ]
replication_count_data <- count_data_filtered[, rownames(replication_metadata)]
```

# DGE function
```{r}
dge <- function(counts, meta, design, filename, filename_volcano,
                lfc_threshold = 2, padj_threshold = 0.01, top_n = 10) {
  library(DESeq2)
  library(writexl)
  library(ggplot2)

  dds <- DESeqDataSetFromMatrix(countData = round(counts),
                                colData = meta,
                                design = design)
  dds <- DESeq(dds, parallel = FALSE)

  save_dds <- readline(prompt = "Save DESeqDataSet object? (yes/no): ")
  if (tolower(save_dds) == "yes") {
    dds_filename <- readline(prompt = "Enter filename to save DESeqDataSet object (e.g., dds.rds): ")
    saveRDS(dds, dds_filename)
  }
  
  cat("\nCoefficients:\n")
  print(resultsNames(dds))

  mode_choice <- readline(prompt = "\nUse 'coef' or 'contrast'? ")
  
  if (tolower(mode_choice) == "coef") {
    coef_choice <- readline(prompt = "Enter the coefficient name: ")
    res <- lfcShrink(dds, coef = coef_choice, type = "apeglm") |>
      as.data.frame() |>
      rownames_to_column("gene_names")
    
  } else if (tolower(mode_choice) == "contrast") {
    cat("\nEnter contrast as a single R expression.\n")
    cat("Examples:\n")
    cat("# Biological Question                               | Intercept Model (~ genotype + cond + g:c)                    | No-Intercept Model (~ 0 + group)\n")
    cat("# --------------------------------------------------------------------------------------------------------------------------\n")
    cat("# Condition effect in Genotype I (B vs A in I)       | results(dds, name=\"condition_B_vs_A\")                     | results(dds, contrast=list(\"groupI_B\", \"groupI_A\"))\n")
    cat("# Condition effect in Genotype II (B vs A in II)     | results(dds, list(c(\"condition_B_vs_A\", \"genotypeII.conditionB\"))) | results(dds, contrast=list(\"groupII_B\", \"groupII_A\"))\n")
    cat("# Interaction effect (Is B vs A different in II vs I?) | results(dds, name=\"genotypeII.conditionB\")               | results(dds, contrast=list(c(\"groupII_B\", \"groupI_A\"), c(\"groupII_A\", \"groupI_B\")))\n")
    cat("# ---------------------------------------------------------------------------\n")
    cat("Wrap the contrast in list(), e.g. list(\"Condition_Treated_vs_Control\") or list(\"Batch1.ConditionControl\", \"Batch9.ConditionControl\")\n\n")
    
    contrast_input <- readline(prompt = "Enter your contrast: ")
    contrast_list <- eval(parse(text = contrast_input))
    
    res <- lfcShrink(dds, contrast = contrast_list, type = "ashr") |>
      as.data.frame() |>
      rownames_to_column("gene_names")
    
  } else {
    stop("Invalid input")
  }

  resOrdered <- res[order(res$padj), ]
  write_xlsx(resOrdered, filename)

  volcano <- volcano_plot(resOrdered,
                          gene_label_col = "gene_names",
                          lfc_threshold = lfc_threshold,
                          padj_threshold = padj_threshold,
                          top_n = top_n)
  ggsave(
    filename = filename_volcano,
    plot = volcano,
    device = "jpeg",
    units = "in",
    height = 8,
    width = 15,
    dpi = 600
  )

  return(resOrdered)
}
```

# Finding differences between patients of Batches 1 to 7 and Batches 8 and 9
```{r, eval=FALSE}
metadata_frda_remove_fxn_abnormal <- metadata_frda_remove_fxn_abnormal |>
  mutate(Batch_group = ifelse(Batch %in% 1:7, "Batch 1-7", "Batch 8-9"),
         GAA1_GAA2 = GAA1 + GAA2) |>
  filter(Condition == "Patient") |>
  mutate(across(c(Age, DD, Onset, GAA1, GAA2, GAA1_GAA2), as.numeric))

plot_box_jitter_vars <- function(data, y_vars, group_col = "Batch_group") {
  
  plots <- lapply(y_vars, function(var) {
    ggplot(data, aes_string(x = group_col, y = var)) +
      geom_boxplot(outlier.shape = NA, fill = "lightblue") +
      geom_jitter(width = 0.2, size = 2, alpha = 0.7, color = "darkblue") +
      theme_bw(base_size = 14)
  })

  names(plots) <- y_vars
  return(plots)
}

vars_to_plot <- c("Age", "DD", "Onset", "GAA1", "GAA2", "GAA1_GAA2")
plots <- plot_box_jitter_vars(metadata_frda_remove_fxn_abnormal, vars_to_plot)
wrap_plots(plots, ncol = 3)

# Read alignment differences
reads_aligned <- read_excel("QC/QC/qc_result.xlsx", sheet = "millions_aligned")

p <- ggplot(reads_aligned, aes(x = Sample, y = `M Aligned`)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = round(`M Aligned`, 1)), vjust = -0.5, size = 6) +
  facet_grid(. ~ Condition + Batch, scales = "free_x", space = "free_x") +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw(base_size = 18) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Samples", y = "Millions aligned")

ggsave("QC/QC/reads_aligned.jpeg",
       plot = p,
       device = "jpeg",
       units = "in",
       height = 20,
       width = 50,
       dpi = 600,
       limitsize = FALSE)
```

# DE for batch 8 and 9 patients and controls
```{r}
# Selecting samples that have million mapped reads to the transcriptome > 5 
# and million mapped fragments to the exonic region of the genome > 10

qc_result <- read_excel("QC/qc_dragen_salmon.xlsx", skip = 1)
samples_qualified <- qc_result |>
  filter(Batch %in% c(8, 9)) |> 
  mutate(
    `M Aligned` = as.numeric(`M Aligned`),
    Exonic = as.numeric(Exonic)
  ) |> 
  filter(`M Aligned` > 5 & `Exonic` > 10) |> # exonic info available for batch 8 and 9 only
  pull(Sample)

metadata_frda_batch8_9 <- metadata_frda |>
  filter(Batch %in% c(8, 9) & rownames(metadata_frda) %in% samples_qualified)
metadata_frda_batch8_9$Batch <- factor(metadata_frda_batch8_9$Batch)
count_data_frda_batch8_9 <- count_data_filtered[, rownames(metadata_frda_batch8_9)]

# batch8_9_result <- dge(counts = count_data_frda_batch8_9, 
#                       meta = metadata_frda_batch8_9,
#                       design = ~ Batch + Sex + Age_scaled + Condition,
#                       filename = "res/res_batch8_9_patients_vs_controls.xlsx",
#                       filename_volcano = "volcano_plot/volcano_batch8_9_patients_vs_controls.jpeg")
```

# Pathway Analysis for batch 8 and 9 DGE results
```{r, eval=FALSE}
dge_batch_8_9 <- read_xlsx("res/res_batch8_9_patients_vs_controls.xlsx")
top_genes <- dge_batch_8_9 |> 
  filter(padj < 0.01 & abs(log2FoldChange) >= 1) |> 
  pull(gene_names)
```

# GO enrichment (Overrepresentation analysis using hypergeometric test)
```{r, eval=FALSE}
go_gprofiler2 <- gost(query = top_genes,
                  organism = "hsapiens",
                  sources = c("GO:BP", "GO:MF", "GO:CC", "KEGG", "REAC", "TF"),
                  correction_method = "fdr",
                  user_threshold = 0.05,
                  significant = TRUE)

gostplot(go_gprofiler2, capped = TRUE, interactive = TRUE)

go_clusterprof <- enrichGO(gene = top_genes,
                            OrgDb = org.Hs.eg.db,
                            keyType = "SYMBOL",
                            ont = "ALL",
                            pAdjustMethod = "BH",
                            pvalueCutoff = 0.05,
                            qvalueCutoff = 0.05)

dotplot(go_clusterprof, showCategory = 20)
ggsave("pathway_enrichment/go_enrichment_batch8_9_patients_vs_controls.jpeg",
       plot = last_plot(),
       device = "jpeg",
       units = "in",
       height = 8,
       width = 12,
       dpi = 600)

write_xlsx(as.data.frame(go_clusterprof), "pathway_enrichment/go_enrichment_batch8_9_patients_vs_controls.xlsx")
```

# Enquire GSEA gene sets
```{r, eval=FALSE}
msigdbr::msigdbr_species()
msigdbr_list <- msigdbr(species = "Homo sapiens")

msigdbr_list |> 
  distinct(gs_collection, gs_subcollection) |> 
  arrange(gs_collection, gs_subcollection) |> 
  View()
```

# GSEA function
```{r}
run_multi_gsea <- function(dge_df,
                           sets = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                                    "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
                           output_prefix = "pathway_enrichment",
                           species = "Homo sapiens") {
  
  suppressPackageStartupMessages({
    library(msigdbr)
    library(clusterProfiler)
    library(tidyverse)
    library(openxlsx)
    library(ggplot2)
    library(patchwork)
    library(enrichplot)
  })

  gene_sets <- lapply(setNames(sets, sets), function(x){
    msigdbr(species = species, subcollection = x)
  })
  
  # Filtering genes for those present in DESeq results
  gene_sets <- lapply(gene_sets, function(sets){
    sets[sets$gene_symbol %in% dge_df$gene_names, ]
  })

  filtered_df <- dge_df |> 
    filter(!is.na(log2FoldChange), !is.na(padj)) |>
    arrange(desc(abs(log2FoldChange))) |> 
    distinct(gene_names, .keep_all = TRUE)

  # Replacing padj = 0
  filtered_df <- filtered_df |> 
    mutate(padj = ifelse(padj == 0, .Machine$double.xmin, padj))

  # Ranking metric: sign(LFC) x –log10(padj)
  ranking_vector <- sign(filtered_df$log2FoldChange) * -log10(filtered_df$padj)
  names(ranking_vector) <- filtered_df$gene_names
  ranking_vector <- ranking_vector[is.finite(ranking_vector)]
  ranking_vector <- sort(ranking_vector, decreasing = TRUE)
  # Adding tiny jitter only if ties are present
  if (any(duplicated(ranking_vector))) {
    ranking_vector <- ranking_vector + rnorm(length(ranking_vector), 0, 1e-8)
    ranking_vector <- sort(ranking_vector, decreasing = TRUE)
  }

  gsea_results <- lapply(names(gene_sets), function(set_name){
    message(paste0("Running: ", set_name))
    
    gs_df <- gene_sets[[set_name]]
    
    gsea_res <- GSEA(
        geneList = ranking_vector,
        TERM2GENE = gs_df |> select(gs_name, gene_symbol),
        minGSSize = 10,
        maxGSSize = 500,
        pvalueCutoff = 0.05,
        pAdjustMethod = "BH",
        eps = 0,
        nPermSimple = 10000,
        seed = TRUE
      )
    
    if (is.null(gsea_res) || nrow(gsea_res@result) == 0) {
      message(paste0("No significant pathways in ", set_name))
      return(NULL)
    }
    
    df <- gsea_res@result |> arrange(p.adjust)
    df$Description <- stringr::str_trunc(df$Description, width = 50)
    # Top pathway
    top_path <- df$ID[1]
    
    # Bubble plot
    if (nrow(df) >= 1) {
      p1 <- df |> 
        slice(1:min(20, nrow(df))) |>
        ggplot(aes(x = NES, y = reorder(Description, NES),
                   size = setSize, fill = p.adjust)) +
        geom_point(shape = 21) +
        theme_minimal() +
        scale_fill_viridis_c(trans = "log10") +
        ggtitle(paste0(set_name, " — Bubble Plot")) +
        xlab("NES") + ylab("")
      
      ggsave(
        paste0(output_prefix, "/GSEA_", gsub(":", "_", set_name), "_bubble.png"),
        p1, width = 10, height = 6
      )
    }
    
    # Running score plot
    p2 <- gseaplot2(
      gsea_res, geneSetID = top_path,
      title = paste0(set_name, ": ", df$Description[1])
    )
    
    ggsave(
      paste0(output_prefix, "/GSEA_", gsub(":", "_", set_name), "_running_score.png"),
      p2, width = 8, height = 6
    )
    
    return(gsea_res@result)
  })
  
  names(gsea_results) <- gsub(":", "_", sets)
  write.xlsx(gsea_results, paste0(output_prefix, "/GSEA_results.xlsx"))
  
  return(gsea_results)
}
```

# Running GSEA for batch 8 and 9 DGE results
```{r, eval=FALSE}
gsea_batch8_9 <- run_multi_gsea(dge_df = dge_batch_8_9,
                                 sets = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                                          "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
                                 output_prefix = "pathway_enrichment",
                                 species = "Homo sapiens")
```

# GSVA function
```{r}
run_gsva_pipeline <- function(
  vst_object,
  msigdb_list = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                  "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
  output_excel = "GSVA_results.xlsx",
  output_dir = "pathway_enrichment",
  assay_name = "counts",
  kcdf_mode = "Gaussian",
  width = 15,
  height = 10
) {

  suppressPackageStartupMessages({
    library(GSVA)
    library(SummarizedExperiment)
    library(msigdbr)
    library(limma)
    library(sva)
    library(ComplexHeatmap)
    library(circlize)
    library(RColorBrewer)
    library(openxlsx)
    library(tidyverse)
    library(grid)
  })

  # ensure output dir
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

  wb <- createWorkbook()

  message("Available columns in colData(vst_object):")
  print(colnames(colData(vst_object)))

  ## Ask user for design (variables used to build model)
  design_vars <- readline(prompt =
    "Enter variables for the design matrix (e.g. 'Batch + Sex + Age + Condition'): ")
  design_formula <- as.formula(paste0("~ ", design_vars))

  ## Ask user for annotation column (for heatmap)
  annot_col <- readline(prompt =
    "Enter the column name in colData(vst_object) to color in the heatmap (e.g. 'Condition'): ")
  if (!(annot_col %in% colnames(colData(vst_object)))) {
    stop("Annotation column not found in colData(vst_object). Aborting.")
  }
  annot_values <- unique(as.character(colData(vst_object)[[annot_col]]))
  message("Annotation groups detected:")
  print(annot_values)

  ## Ask user for annotation colors (produce named character vector)
  annot_colors <- character(length(annot_values))
  names(annot_colors) <- annot_values
  for (val in annot_values) {
    col_in <- readline(prompt = paste0("Enter color for group '", val,
                                       "' (e.g. 'salmon' or 'lightgreen') [press Enter to default 'grey']: "))
    if (col_in == "") col_in <- "grey"
    annot_colors[val] <- col_in
  }

  ## Build model matrices once from vst_object
  mod <- model.matrix(design_formula, colData(vst_object))
  mod0 <- model.matrix(~1, colData(vst_object))

  message("Available coefficients from the model (will be tested):")
  print(colnames(mod))
  coef_user <- readline(prompt = "Enter coefficient to test (exact column name, e.g. 'ConditionPatient'): ")
  if (!(coef_user %in% colnames(mod))) {
    hits <- grep(coef_user, colnames(mod), value = TRUE)
    if (length(hits) == 0) stop("Coefficient not found in model columns. Aborting.")
    message("Your input matched the following column(s): ", paste(hits, collapse = ", "))
    coef_user <- hits[1]
  }

  ## color scale for heatmap rows
  pwyexpcol <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
  pwyexpcol <- rev(pwyexpcol)

  results_list <- list()

  for (collection in msigdb_list) {
    message("\nProcessing collection: ", collection, "\n")

    # cleaned name for files
    collection_clean <- gsub("[^A-Za-z0-9_]", "_", collection)
    collection_clean <- substr(collection_clean, 1, 31)

    msig_df <- tryCatch(
      msigdbr(species = "Homo sapiens", subcollection = collection),
      error = function(e1) tryCatch(msigdbr(species = "Homo sapiens", subcollection = collection),
                                   error = function(e2) NULL)
    )
    if (is.null(msig_df) || nrow(msig_df) == 0) {
      warning("msigdbr could not find collection '", collection, "'. Skipping.")
      next
    }

    gene_sets_list <- split(msig_df$gene_symbol, msig_df$gs_name)
    gene_sets_list <- lapply(gene_sets_list, function(pathway) intersect(pathway, rownames(vst_object)))
    gene_sets_list <- gene_sets_list[sapply(gene_sets_list, length) >= 1] # drop empty gene-sets

    if (length(gene_sets_list) == 0) {
      warning("No overlapping gene sets between collection '", collection, "' and vst_object. Skipping.")
      next
    }

    ## GSVA
    gsvapar <- gsvaParam(
      vst_object,
      geneSets = gene_sets_list,
      assay = assay_name,
      kcdf = kcdf_mode,
      minSize = 10,
      maxDiff = TRUE,
      absRanking = FALSE
    )

    es <- gsva(gsvapar)

    ## Save GSVA full matrix to workbook sheet
    gsva_df <- as.data.frame(assay(es)) |> rownames_to_column("Pathway")
    addWorksheet(wb, sheetName = collection_clean)
    writeData(wb, sheet = collection_clean, gsva_df)

    ## copy global model matrix and use locally
    mod_local <- mod
    mod0_local <- mod0

    ## SVA (estimate surrogate variables from GSVA scores) to estimate sample-level heterogeneity
    sv <- sva(assay(es), mod_local, mod0_local)
    mod_local <- cbind(mod_local, sv$sv)

    ## Fit limma
    fit <- lmFit(assay(es), mod_local)
    fit.eb <- eBayes(fit, robust = TRUE)
    gssizes <- geneSetSizes(es)
    fit.eb.trend <- eBayes(fit.eb, robust = TRUE, trend = gssizes)

    tt <- topTable(fit.eb.trend, coef = coef_user, n = Inf)
    DEpwys <- rownames(tt)[!is.na(tt$adj.P.Val) & tt$adj.P.Val <= 0.05]

    if (length(DEpwys) == 0) {
      message("No DE pathways found (FDR <= 0.05) for collection: ", collection)
      results_list[[collection_clean]] <- list(GSVA_matrix = assay(es), DE_table = tt, DE_matrix = NULL)
      next
    }

    message("Found ", length(DEpwys), " DE pathways for collection: ", collection)

    ## find condition columns in mod_local
    cond_cols <- which(colnames(mod_local) == coef_user)
    if (length(cond_cols) == 0) {
      ## try to infer variable name (e.g., ConditionPatient -> Condition)
      var_hint <- sub("([A-Za-z0-9_.-]+).*", "\\1", coef_user)
      cond_cols <- grep(paste0("^", var_hint), colnames(mod_local))
    }
    if (length(cond_cols) == 0) stop("Cannot determine condition column(s) for coef: ", coef_user)

    # covariates: drop intercept (col 1) and condition columns
    all_cols <- seq_len(ncol(mod_local))
    covar_cols <- setdiff(all_cols, c(1, cond_cols))
    if (length(covar_cols) == 0) covar_mat <- NULL else covar_mat <- mod_local[, covar_cols, drop = FALSE]

    # Remove covariates effect for plotting
    DEpwys_es_all <- removeBatchEffect(
      assay(es[DEpwys, , drop = FALSE]),
      covariates = covar_mat,
      design = mod_local[, cond_cols, drop = FALSE]
    )

    # Select top 30 pathways by adj.P.Val
    top_n <- min(30, nrow(DEpwys_es_all))
    top_idx <- order(tt[DEpwys, "adj.P.Val"])[1:top_n]
    DEpwys_es <- DEpwys_es_all[top_idx, , drop = FALSE]

    # Truncate pathway names
    rownames(DEpwys_es) <- stringr::str_trunc(rownames(DEpwys_es), width = 50)

    # cluster pathways
    gsetClust <- hclust(as.dist(1 - cor(t(DEpwys_es), method = "pearson")), method = "complete")

    # prepare annotation (use vst_object metadata)
    sample_annot <- as.character(colData(vst_object)[[annot_col]])
    names(sample_annot) <- colnames(es) # ensure names match columns in DEpwys_es

    ann <- HeatmapAnnotation(
      Annotation = sample_annot,
      col = list(Annotation = annot_colors),
      show_annotation_name = FALSE,
      show_legend = FALSE
    )

    # truncate long pathway names for display (optional)
    rownames(DEpwys_es) <- stringr::str_trunc(rownames(DEpwys_es), width = 50)

    # Save heatmap
    out_pdf <- file.path(output_dir, paste0("GSVA_DEpws_", collection_clean, "_heatmap.pdf"))
    pdf(out_pdf, width = width, height = height)

    ht <- Heatmap(
      DEpwys_es,
      name = "GSVA Enrichment Score",
      col = pwyexpcol,
      cluster_rows = gsetClust,
      show_row_names = TRUE,
      row_names_gp = gpar(fontsize = 8),  
      column_names_gp = gpar(fontsize = 8),
      cluster_columns = FALSE,
      show_column_names = TRUE,
      top_annotation = ann,
      show_heatmap_legend = FALSE
    )

    gsva_enrichment_legend <- Legend(
      title = "GSVA Enrichment Score",
      col_fun = colorRamp2(
        breaks = c(-max(abs(DEpwys_es)), 0, max(abs(DEpwys_es))),
        colors = pwyexpcol[c(1, 128, 256)]
      ),
      at = seq(-max(abs(DEpwys_es)), max(abs(DEpwys_es)), length.out = 5),
      labels = round(seq(-max(abs(DEpwys_es)), max(abs(DEpwys_es)), length.out = 5), 2),
      title_gp = gpar(fontsize = 8, fontface = "bold"),
      labels_gp = gpar(fontsize = 5)
    )

    condition_legend <- Legend(
      labels = names(annot_colors),
      title = annot_col,
      legend_gp = gpar(fill = annot_colors),
      title_gp = gpar(fontsize = 8, fontface = "bold"),
      labels_gp = gpar(fontsize = 8)
    )

    combine_legends <- packLegend(gsva_enrichment_legend, condition_legend, direction = "vertical")

    draw(ht, heatmap_legend_side = "left", annotation_legend_side = "left", 
         heatmap_legend_list = combine_legends, padding = unit(c(5, 5, 5, 35), "mm")) #  bottom, left, top, right,
    dev.off()

    results_list[[collection_clean]] <- list(GSVA_matrix = assay(es), DE_table = tt, DE_matrix = DEpwys_es)

    message("Saved heatmap: ", out_pdf)
  }

  # save workbook inside output_dir
  out_wb <- file.path(output_dir, output_excel)
  saveWorkbook(wb, out_wb, overwrite = TRUE)
  message("Saved combined GSVA workbook: ", out_wb)

  message("GSVA pipeline finished. Returning results as a list.")
  return(invisible(results_list))
}
```

# Running GSVA for batch 8 and 9 DGE results
```{r, eval=FALSE}
dds_batch8_9 <- readRDS("dds_batch8_9.rds")
vst_batch8_9 <- DESeq2::vst(dds_batch8_9, blind = FALSE)
SummarizedExperiment::assayNames(vst_batch8_9) <- "counts"

gsva_batch8_9 <- run_gsva_pipeline(
  vst_object = vst_batch8_9,
  msigdb_list = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                  "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
  output_excel = "GSVA_results.xlsx",
  output_dir = "pathway_enrichment",
  assay_name = "counts",
  kcdf_mode = "Gaussian"
)
```

# DE among patients of batches 8, 9 with (1) and without HCM (0)
```{r, eval=FALSE}
metadata_frda_batch8_9_patients <- metadata_frda_batch8_9 |> filter(Condition == "Patient")
metadata_frda_batch8_9_patients$Condition <- droplevels(metadata_frda_batch8_9_patients$Condition)
count_data_frda_batch8_9_patients <- count_data_filtered[, rownames(metadata_frda_batch8_9_patients)]

hcm_batch8_9_patients_result <- dge(counts = count_data_frda_batch8_9_patients,
                            meta = metadata_frda_batch8_9_patients,
                            design = ~ Batch + Sex + Age + HCM,
                            filename = "res/res_batch8_9_hcm_vs_non_hcm.xlsx",
                            filename_volcano = "volcano_plot/volcano_batch8_9_hcm_vs_non_hcm.jpeg")
```

# WGCNA for batch 8, 9
```{r, eval=FALSE}
allowWGCNAThreads()

dds_batch8_9_wgcna <- DESeqDataSetFromMatrix(countData = round(count_data_frda_batch8_9),
                                colData = metadata_frda_batch8_9, design = ~ 1)
vst_batch8_9_wgcna <- vst(dds_batch8_9_wgcna)
expr_vst_batch8_9_wgcna <- assay(vst_batch8_9_wgcna)
expr_rb_batch8_9_wgcna <- removeBatchEffect(expr_vst_batch8_9_wgcna, batch = metadata_frda_batch8_9$Batch,
                                           covariates = model.matrix(~ Sex + Age, data = metadata_frda_batch8_9)[, -1],
                                           design = NULL)

# Identifying genes and samples with excessive number of missing values
gsg <- goodSamplesGenes(t(expr_rb_batch8_9_wgcna), verbose = 3)
gsg$allOK

if (!gsg$allOK) {
  if (sum(!gsg$goodGenes) > 0)
    printFlush(paste("Removing genes:", paste(colnames(t(expr_rb_batch8_9_wgcna))[!gsg$goodGenes], collapse = ", ")))
  if (sum(!gsg$goodSamples) > 0)
    printFlush(paste("Removing samples:", paste(rownames(t(expr_rb_batch8_9_wgcna))[!gsg$goodSamples], collapse = ", ")))
  expr_rb_batch8_9_wgcna <- expr_rb_batch8_9_wgcna[gsg$goodGenes, gsg$goodSamples]
  metadata_frda_batch8_9_wgcna <- metadata_frda_batch8_9[gsg$goodSamples, ]
}

# Clustering samples by Euclidean distance to detect outlier samples
sample_tree <- hclust(dist(t(expr_rb_batch8_9_wgcna)), method = "average")
plot(sample_tree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
# abline(h = 130, col = "red") # adjust height threshold as needed
dev.copy(png, filename = "wgcna/wgcna_sample_clustering_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Determine cluster under the line
# clust <- cutreeStatic(sample_tree, cutHeight = 200, minSize = 10)
# table(clust)
# clust 1 contains the samples we want to keep.
# keepSamples = (clust==1)

# Remove outlier sample FA102
outlier_sample <- "FA102"
expr_rb_batch8_9_wgcna <- expr_rb_batch8_9_wgcna[, colnames(expr_rb_batch8_9_wgcna) != outlier_sample]
metadata_frda_batch8_9_wgcna <- metadata_frda_batch8_9_wgcna[rownames(metadata_frda_batch8_9_wgcna) != outlier_sample, ]

# Recluster samples after removing outlier
sample_tree <- hclust(dist(t(expr_rb_batch8_9_wgcna)), method = "average")
plot(sample_tree, main = "Sample clustering after outlier removal", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
dev.copy(png, filename = "wgcna/wgcna_sample_clustering_batch8_9_outlier_removed.png", width = 2000, height = 1500, res = 150)
dev.off()

# Automatic network construction and module detection
norm_count_data <- t(expr_rb_batch8_9_wgcna)

# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))

# Call the network topology analysis function
sft <- pickSoftThreshold(norm_count_data,
                  powerVector = power,
                  networkType = "signed",
                  verbose = 5)

sft.data <- sft$fitIndices

# visualization to pick power
# ideal power should have signed R^2 > 0.9 and minimal mean connectivity
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_text() +
  geom_hline(yintercept = 0.8, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()

a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_text() +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()
  
grid.arrange(a1, a2, nrow = 2)
dev.copy(png, filename = "wgcna/wgcna_soft_thresholding_power_selection_batch8_9.png", width = 2000, height = 2500, res = 150)
dev.off()

soft_power <- 6
temp_cor <- cor # store original cor function to temporarily override
cor <- WGCNA::cor

bwnet <- blockwiseModules(norm_count_data,
                 maxBlockSize = 14000,
                 minModuleSize = 30,
                 TOMType = "signed",
                 power = soft_power,
                 mergeCutHeight = 0.25,
                 numericLabels = FALSE,
                 saveTOMs = TRUE,
                 saveTOMFileBase = "wgcna/batch8_9_wgcna_TOM",
                 randomSeed = 1234,
                 verbose = 3)

saveRDS(bwnet, file = "wgcna/wgcna_frda_batch8_9.rds")
bwnet <- readRDS("wgcna/wgcna_frda_batch8_9.rds")

cor <- temp_cor

module_eigengenes <- bwnet$MEs
table(bwnet$colors)

# Plot the dendrogram and the module colors underneath for block 1
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors[bwnet$blockGenes[[1]]], bwnet$colors[bwnet$blockGenes[[1]]]),
                    c("unmerged", "merged"),
                    main = "Gene dendogram and module colours in block 1",
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
dev.copy(png, filename = "wgcna/wgcna_gene_dendrogram_block1_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Plot the dendrogram and the module colors underneath for block 2
plotDendroAndColors(bwnet$dendrograms[[2]], cbind(bwnet$unmergedColors[bwnet$blockGenes[[2]]], bwnet$colors[bwnet$blockGenes[[2]]]),
                    c("unmerged", "merged"),
                    main = "Gene dendogram and module colours in block 2",
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
dev.copy(png, filename = "wgcna/wgcna_gene_dendrogram_block2_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Relate modules to external traits
metadata_frda_batch8_9_wgcna$condition_categorize <- ifelse(metadata_frda_batch8_9_wgcna$Condition == "Control", 0, 1)
metadata_frda_batch8_9_wgcna$sex_categorize <- ifelse(metadata_frda_batch8_9_wgcna$Sex == "F", 0, 1)

col_to_fill_zero <- c("HCM", "Diabetes", "mFARS total", "mFARS USS", "FSA scale")
metadata_frda_batch8_9_wgcna[col_to_fill_zero] <- lapply(metadata_frda_batch8_9_wgcna[col_to_fill_zero], function(x) {
  x[is.na(x)] <- 0
  return(x)
})

col_to_num_convert <- c("HCM", "Diabetes", "mFARS total", "mFARS USS", "FSA scale")
metadata_frda_batch8_9_wgcna[col_to_num_convert] <- lapply(metadata_frda_batch8_9_wgcna[col_to_num_convert], function(x) {
  as.numeric(as.character(x))
})

trait_data <- metadata_frda_batch8_9_wgcna |> 
  select(condition_categorize, HCM, Diabetes, Age, sex_categorize, GAA1, GAA2, `FSA scale`,  `mFARS total`, `mFARS USS`)

nSamples <- nrow(norm_count_data)
nGenes <- ncol(norm_count_data)

module_trait_cor <- cor(module_eigengenes, trait_data, use = "p", method = "pearson")
module_trait_pvalue <- corPvalueStudent(module_trait_cor, nSamples)

# Heatmap of module-trait relationships
heatmap.data <- merge(module_eigengenes, trait_data, by = 'row.names')
heatmap.data <- heatmap.data |> 
  column_to_rownames(var = 'Row.names')

module_eigengenes_length <- ncol(module_eigengenes)
trait_data_length <- ncol(trait_data)

CorLevelPlot(heatmap.data,
             x = names(heatmap.data)[module_eigengenes_length + 1:trait_data_length],
             y = names(heatmap.data)[1:module_eigengenes_length],
             col = c("green", "lightgreen", "white", "pink", "red"))
dev.copy(png, filename = "wgcna/wgcna_module_trait_relationships_batch8_9.png", width = 2000, height = 1500, res = 150)
dev.off()

# Extract genes in significant modules
significant_modules <- module_trait_pvalue |> 
  as.data.frame() |> 
  rownames_to_column(var = "Module") |> 
  pivot_longer(-Module, names_to = "Trait", values_to = "pvalue") |> 
  filter(pvalue < 0.01) |> 
  pull(Module) |> 
  unique()

output_list <- list()

for (mod in significant_modules) {
  mod_color <- sub("ME", "", mod) |> tolower()
  genes_in_module <- names(bwnet$colors)[bwnet$colors == mod_color]
  
  output_list[[mod]] <- data.frame(Gene = genes_in_module)
}

write_xlsx(output_list, "wgcna/genes_in_significant_modules_batch8_9.xlsx")

# Enrichment analysis for genes in significant modules
GO_enrichment_results <- list()

for (mod in significant_modules) {
  genes_in_module <- output_list[[mod]]$Gene
  
  go_enrich <- enrichGO(gene = genes_in_module,
                        OrgDb = org.Hs.eg.db,
                        keyType = "SYMBOL",
                        ont = "ALL",
                        pAdjustMethod = "BH",
                        pvalueCutoff = 0.05,
                        qvalueCutoff = 0.05)
  
  GO_enrichment_results[[mod]] <- go_enrich
  
  p <- dotplot(go_enrich, showCategory = 20) +
    ggtitle(paste0("GO Enrichment for Module ", mod))
  
  ggsave(paste0("wgcna/GO_enrichment_module_", mod, "_batch8_9.png"),
         plot = p,
         width = 10,
         height = 6,
         dpi = 300)
}

write.xlsx(GO_enrichment_results, "wgcna/go_enrichment_significant_modules_batch8_9.xlsx")

# Enrichment analysis using Enrichr
websiteLive <- getOption("enrichR.live")

if (websiteLive) {
    listEnrichrSites()
    setEnrichrSite("Enrichr")  # Human genes
    
    # List of available databases
    dbs <- listEnrichrDbs()
    View(dbs)
}

dbs <- c("ClinVar_2025",
         "GWAS_Catalog_2025",
         "GO_Biological_Process_2025",
         "GO_Cellular_Component_2025",
         "GO_Molecular_Function_2025",
         "Reactome_Pathways_2024",
         "WikiPathways_2024_Human",
         "KEGG_2019_Human")

enrichr_results <- list()

if (websiteLive) {
  for (mod in significant_modules) {
  genes_in_module <- output_list[[mod]]$Gene
  
  enrichr_enrich <- enrichr(genes_in_module, dbs)

  for (db in names(enrichr_enrich)) {
    enrichr_results[[paste0(mod, "_", db)]] <- enrichr_enrich[[db]]

    p <- plotEnrich(enrichr_enrich[[db]], showTerms = 20, y = "Count", orderBy = "P.value", title = paste0("Enrichr ", db, " for Module ", mod))
    
    ggsave(paste0("wgcna/enrichr_", gsub(" ", "_", tolower(db)), "_module_", mod, "_batch8_9.png"),
           plot = p,
           width = 10,
           height = 6,
           dpi = 300)
  }
}}

clean_name <- function(x) substr(x, 1, 31)
names(enrichr_results) <- sapply(names(enrichr_results), clean_name)
write.xlsx(enrichr_results, "wgcna/enrichr_significant_modules_batch8_9.xlsx")
```

# Final samples across all batches for analysis
```{r}
# Removing samples from batches 8 and 9
samples_batch_1_7 <- metadata_frda |> 
  filter(Batch %in% 1:7) |> 
  rownames()

samples_batch_8_9 <- samples_qualified

samples_all_frda <- c(samples_batch_1_7, samples_batch_8_9) # 150 samples
metadata_frda_all <- metadata_frda[samples_all_frda, ]
order_index <- order(metadata_frda_all$Condition == "Patient", decreasing = TRUE)
metadata_frda_all <- metadata_frda_all[order_index, ]
count_data_frda_all <- count_data_filtered[, samples_all_frda]
count_data_frda_all <- count_data_frda_all[, order_index]

dds_frda_all <- readRDS("dds_frda_all_ensg_removed.rds")
vst_frda_all <- vst(dds_frda_all, blind = FALSE)
assayNames(vst_frda_all) <- "counts"
expr_vst <- assay(vst_frda_all)
covs <- model.matrix(~ Sex + Age + Condition, data = metadata_frda_all)
expr_rb <- limma::removeBatchEffect(expr_vst, batch = metadata_frda_all$Batch, design = covs)
```

# Analysis for all FRDA samples across batches 1-9
```{r, eval=FALSE}
# PCA before and after removing batch effects
before <- plot_pca(
  count_data_frda_all, 
  metadata_frda_all, 
  top_n = 500,
  color_by = "Batch",
  shape_by = "Condition",
  title = "PCA before batch effect removal (Top 500 variable genes)")

after <- plot_pca(
  expr_rb,
  metadata_frda_all,
  top_n = 500,
  color_by = "Batch",
  shape_by = "Condition",
  title = "PCA after batch effect removal (Top 500 variable genes)")

png("pca_before_after_ensg_removed.png", width = 18, height = 11, units = "in", res = 600)
before + after
dev.off()

# Sample-sample correlation of expression values across all genes
dds_sample_cor <- DESeqDataSetFromMatrix(countData = round(count_data_frda_all), 
                                          colData   = metadata_frda_all,
                                          design    = ~ 1) # no experimental variables are modeled or batch effects are removed
vst_mat_sample_cor <- vst(dds_sample_cor, blind = TRUE) # blind TRUE ignores design
cor_mat <- cor(assay(vst_mat_sample_cor), method = "pearson")
rb_mat_sample_cor <- removeBatchEffect(assay(vst_mat_sample_cor), batch = metadata_frda_all$Batch)
cor_mat_rb <- cor(rb_mat_sample_cor, method = "pearson")

batch_levels <- levels(metadata_frda_all$Batch)
batch_colors <- setNames(colorRampPalette(brewer.pal(8, "Set2"))(length(batch_levels)), batch_levels)
condition_colors <- c(Control = "#1F78B4", Patient = "#E31A1C")
ann_colors <- list(Condition = condition_colors, Batch = batch_colors)

annotation_col <- metadata_frda_all[, c("Condition", "Batch")]
annotation_col <- annotation_col[colnames(cor_mat), , drop = FALSE]

plot <- pheatmap(
  cor_mat_rb,
  name = "Pearson r",
  annotation_col = annotation_col,
  annotation_colors = ann_colors,
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation",
  clustering_method = "average",
  main = "Sample–Sample Correlation"
)
dev.copy(pdf, "QC/sample_sample_correlation_after_batch_effect_removal.pdf", width = 20, height = 20)
dev.off()

# Differential expression analysis between all patients and controls
all(rownames(metadata_frda_all) == colnames(count_data_frda_all))
dge_frda_all <- dge(counts = count_data_frda_all,
                    meta = metadata_frda_all,
                    design = ~ Batch + Sex + Age + Condition,
                    filename = "res/res_all_frda_patients_vs_controls.xlsx",
                    filename_volcano = "volcano_plot/volcano_all_frda_patients_vs_controls.jpeg")

# Differential expression analysis between all patients and controls after ensg genes removed
all(rownames(metadata_frda_all) == colnames(count_data_frda_all))
dge_frda_all <- dge(counts = count_data_frda_all,
                    meta = metadata_frda_all,
                    design = ~ Batch + Sex + Age + Condition,
                    filename = "res/res_all_frda_patients_vs_controls_ensg_removed.xlsx",
                    filename_volcano = "volcano_plot/volcano_all_frda_patients_vs_controls_ensg_removed.jpeg")
# Volcano plot with lfc < -1 and lfc > 1 with padj < 0.05 highlighted
res <- read_xlsx("res/res_all_frda_patients_vs_controls_ensg_removed.xlsx")
vol_data <- res |>
    na.omit() |> 
    mutate(Expression = case_when(
      log2FoldChange >= 1 & padj <= 0.05 ~ "Upregulated",
      log2FoldChange <= -1 & padj <= 0.05 ~ "Downregulated",
      TRUE ~ "Not significant"
    ))

top_20 <- vol_data |>
  filter(Expression %in% c("Upregulated", "Downregulated")) |> 
  arrange(padj) |> 
  head(20)

p <- ggplot(vol_data, aes(x = log2FoldChange, y = -log10(padj))) +
  geom_point(aes(color = Expression), alpha = 0.8, size = 1.5) +
  guides(color = guide_legend(override.aes = list(size = 4))) +
  geom_text_repel(
    data = top_20,
    aes(label = .data[["gene_names"]]),
    size = 1.5,
    max.overlaps = 20,
    force = 10, 
    segment.size = 0.2,
    segment.curvature = -0.5
  ) +
  scale_color_manual(values = c(
    "Upregulated" = "#CB477A",
    "Downregulated" = "#469FBF",
    "Not significant" = "gray70"
  )) +
  scale_x_continuous(name = expression(bold(log[2]("fold change")))) +
  scale_y_continuous(name = expression(bold(-log[10]("adj p")))) +
  geom_hline(yintercept = -log10(0.05), linetype = 2, color = "black") +
  geom_vline(xintercept = c(-1, 1), linetype = 2, color = "black") +
  theme_classic(base_size = 3) +
  theme(
    axis.title = element_text(size = 6, face = "bold"),
    axis.text = element_text(size = 4),
    panel.grid = element_blank(),
    plot.background = element_rect(fill = "white"),
    legend.position = c(0.8, 0.8),
    legend.justification = c(1, 1),
    legend.title = element_text(size = 5, face = "bold"),
    legend.text = element_text(size = 4),
    legend.key.size = unit(0.5, "line")
  )

ggsave("volcano_plot/volcano_all_frda_patients_vs_controls_final.png",
       plot = p,
       device = "png",
       units = "in",
       height = 8.5/3,
       width = 13/3,
       dpi = 600)

# Differential expression analysis between patients with and without HCM among all batches
metadata_frda_patients <- metadata_frda_all |> filter(Condition == "Patient")
count_data_frda_patients <- count_data_frda_all[, rownames(metadata_frda_patients)]

hcm_patients_result <- dge(counts = count_data_frda_patients,
                            meta = metadata_frda_patients,
                            design = ~ Batch + Sex + Age + HCM,
                            filename = "res/res_hcm_vs_non_hcm.xlsx",
                            filename_volcano = "volcano_plot/volcano_hcm_vs_non_hcm.jpeg")

# Pathway enrichment analysis
dge_frda_all <- read_xlsx("res/res_all_frda_patients_vs_controls_ensg_removed.xlsx")
top_genes_all_frda <- dge_frda_all |> 
  filter(!is.na(padj) & (padj < 0.05) & (abs(log2FoldChange) >= 1)) |>
  arrange(padj) |> 
  pull(gene_names)

# GO enrichment
go_clusterprof <- enrichGO(gene = top_genes_all_frda,
                            OrgDb = org.Hs.eg.db,
                            keyType = "SYMBOL",
                            ont = "ALL",
                            pAdjustMethod = "BH",
                            pvalueCutoff = 0.05,
                            qvalueCutoff = 0.05)

dotplot(go_clusterprof, showCategory = 20, split = "ONTOLOGY") + 
  facet_grid(ONTOLOGY ~ ., scales = "free_y") +
  theme(strip.text = element_text(size = 14, face = "bold"))

ggsave("pathway_enrichment/FRDA_All_Batches/go_enrichment_all_batch_patients_vs_controls.jpeg",
       plot = last_plot(),
       device = "jpeg",
       units = "in",
       height = 20,
       width = 12,
       dpi = 600)

write_xlsx(as.data.frame(go_clusterprof), "pathway_enrichment/FRDA_All_Batches/go_enrichment_all_batch_patients_vs_controls.xlsx")

# GSEA
gsea_frda_all <- run_multi_gsea(dge_df = dge_frda_all,
                                 sets = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                                          "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
                                 output_prefix = "pathway_enrichment/FRDA_All_Batches",
                                 species = "Homo sapiens")

# Integrating important pathways from different databases
imp_pathways <- read_xlsx('pathway_enrichment/FRDA_All_Batches/imp_pathways.xlsx')
p <- imp_pathways |> 
  ggplot(aes(x = NES, y = reorder(ID, NES),
            fill = NES, alpha = -log10(p.adjust))) +
  geom_col(width = 0.7) +
  scale_fill_gradient2(
    low = "#3B8BC2",
    high = "#C93A5A",
    name = "NES"
  ) +
  scale_alpha_continuous(
    name = expression(-log[10]("adj p")),
    range = c(0.4, 1)) +
  labs(
    x = "Normalized Enrichment Score (NES)",
    y = NULL
  ) +
  guides(
  fill = guide_colourbar(
    order = 1,
    barheight = unit(1.5, "cm"),
    barwidth  = unit(0.25, "cm"),
    title.theme = element_text(face = "bold", size = 5)
    ),
  alpha = guide_legend(
    order = 2,
    title = expression(bold(-log[10]("adj p"))),
    title.theme = element_text(face = "bold", size = 5),
    keywidth = unit(0.3, "cm"),
    keyheight = unit(0.3, "cm")
    )
  ) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 6, face = "bold"),
    axis.text = element_text(size = 4, face = "bold"),
    panel.grid = element_blank(),
    axis.line = element_line(linewidth = 0.3, colour = "grey40"),
    legend.position = "right",
    legend.text  = element_text(size = 4)
  )

ggsave("pathway_enrichment/FRDA_All_Batches/pathway_enrichment_final_test.png",
       plot = p,
       device = "png",
       units = "in",
       height = 8.5/3,
       width = 13/3,
       dpi = 600)

# GSVA
gsva_frda_all <- run_gsva_pipeline(vst_object = vst_frda_all,
                                  msigdb_list = c("CP:KEGG_LEGACY", "CP:KEGG_MEDICUS", "CP:REACTOME",
                                        "TFT:GTRD", "TFT:TFT_LEGACY", "GO:BP", "GO:CC", "GO:MF", "IMMUNESIGDB"),
                                  output_excel = "GSVA_results.xlsx",
                                  output_dir = "pathway_enrichment/FRDA_All_Batches",
                                  assay_name = "counts",
                                  kcdf_mode = "Gaussian",
                                  width = 25,
                                  height = 10)

# GSVA and boxplot for immune cell types
immune_cell_genes <- read_csv("pathway_enrichment/FRDA_All_Batches/S5_gsva_list.csv")
immune_cell_genes_filt <- immune_cell_genes |> filter(symbol %in% rownames(vst_frda_all))
subset_vst <- vst_frda_all[immune_cell_genes_filt$symbol, ]
gene_sets_list <- split(
  immune_cell_genes_filt$symbol,
  immune_cell_genes_filt$cell_type
)

gsvapar <- gsvaParam(
      subset_vst,
      geneSets = gene_sets_list,
      assay = "counts",
      kcdf = "Gaussian",
      minSize = 1,
      maxDiff = TRUE,
      absRanking = FALSE
    )
es <- gsva(gsvapar)

immune_cells_boxplot_df <- assay(es) |>
  as.data.frame() |>
  rownames_to_column("Cell_type") |>
  pivot_longer(
    cols = -Cell_type,
    names_to = "Sample",
    values_to = "GSVA_score"
  ) |>
  left_join(
    metadata_frda_all |> rownames_to_column("Sample"),
    by = "Sample"
  )

stat_df <- immune_cells_boxplot_df |> 
  group_by(Cell_type) |> 
  wilcox_test(GSVA_score ~ Condition) |> 
  adjust_pvalue(method = "BH") |> 
  add_significance("p.adj") |> 
  left_join(
    immune_cells_boxplot_df |> 
      group_by(Cell_type) |> 
      summarise(y.position = max(GSVA_score, na.rm = TRUE) * 1.1),
    by = "Cell_type"
  )

immune_cells_boxplot_df_sig_nonsig <- immune_cells_boxplot_df |> 
  left_join(stat_df, by = "Cell_type")

plot <- ggplot(immune_cells_boxplot_df_sig_nonsig, aes(x = Condition, y = GSVA_score, fill = Condition)) +
  geom_boxplot(
    outlier.shape = NA, 
    alpha = 0.7, 
    width = 0.35,
    median.linewidth = 0.3
  ) +
  stat_pvalue_manual(
    stat_df,
    label = "p.adj.signif",
    size = 2,
    tip.length = 0.03,
    hide.ns = TRUE,
    y.position = "y.position"
  ) +
  scale_fill_manual(values = c(
      "Control" = "#3B8BC2",
      "Patient" = "#C93A5A"
    )
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +
  facet_wrap(~ Cell_type, scales = "free_y") +
  theme_pubclean(base_size = 7) +
  labs(
    title = NULL,
    x = NULL,
    y = "GSVA score"
    ) +
  theme(
    strip.text = element_text(size = 6, face = "bold"),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 4),
    axis.ticks.x = element_blank(),
    panel.grid = element_blank(),
    legend.title = element_text(size = 5, face = "bold"),
    legend.text = element_text(size = 4),
    legend.position = c(0.83, 0.18),
    # legend.box.background = element_rect(fill = "white", color = "black"),
    # legend.box.margin = margin(15, 20, 15, 20),  # top, right, bottom, left
    legend.background = element_blank())
ggsave("pathway_enrichment/FRDA_All_Batches/gsva_boxplot_immune_genes.png",
       plot = plot,
       device = "png",
       units = "in",
       height = 8.5/3,
       width = 13/3,
       dpi = 600)

# WGCNA
allowWGCNAThreads()

dds_wgcna <- DESeqDataSetFromMatrix(countData = round(count_data_frda_all),
                                colData = metadata_frda_all, design = ~ 1)
vst_wgcna <- vst(dds_wgcna)
expr_vst_wgcna <- assay(vst_wgcna)
expr_rb_wgcna <- removeBatchEffect(expr_vst_wgcna, batch = metadata_frda_all$Batch,
                              covariates = model.matrix(~ Sex + Age, data = metadata_frda_all)[, -1],
                              design = NULL)

gsg <- goodSamplesGenes(t(expr_rb_wgcna), verbose = 3)
gsg$allOK

geneMeans <- rowMeans(expr_rb_wgcna)
geneVars <- apply(expr_rb_wgcna, 1, var)
keep_genes <- (geneMeans > 5) & (geneVars > quantile(geneVars, 0.50))
expr_rb_wgcna_filtered <- expr_rb_wgcna[keep_genes, ]

sample_tree <- hclust(dist(t(expr_rb_wgcna_filtered)), method = "average")
plot(sample_tree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
dev.copy(png, filename = "wgcna/FRDA_All_Batches_gene_sample_filtered/wgcna_sample_clustering_all_batch.png", width = 3000, height = 1500, res = 150)
dev.off()

# Remove outlier samples c("FA102", "FA88", "FA90", "FA87", "FA86", "FA72", "HC20", "FA81", "HC25", "FA99", "FA107")
# Not necessary
outlier_sample <- NULL
expr_rb_wgcna_filtered <- expr_rb_wgcna_filtered[, !colnames(expr_rb_wgcna_filtered) %in% outlier_sample]
metadata_frda_wgcna <- metadata_frda_all[!rownames(metadata_frda_all) %in% outlier_sample, ]

# Recluster samples after removing outlier
sample_tree <- hclust(dist(t(expr_rb_wgcna_filtered)), method = "average")
plot(sample_tree, main = "Sample clustering after outlier removal", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)
dev.copy(png, filename = "wgcna/FRDA_All_Batches_gene_sample_filtered/wgcna_sample_clustering_all_batch_outlier_removed.png", width = 3000, height = 1500, res = 150)
dev.off()

# Reperform sample-sample correlation
cor_mat_outliers_removed <- cor(expr_rb_wgcna_filtered, method = "pearson")
annotation_col <- metadata_frda_wgcna[, c("Condition", "Batch")]
annotation_col <- annotation_col[colnames(cor_mat_outliers_removed), , drop = FALSE]

plot <- pheatmap(
  cor_mat_outliers_removed,
  name = "Pearson r",
  annotation_col = annotation_col,
  annotation_colors = ann_colors,
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation",
  clustering_method = "average",
  main = "Sample–Sample Correlation"
)
dev.copy(pdf, "wgcna/FRDA_All_Batches_gene_sample_filtered/sample_sample_correlation_after_batch_effect_removal_outliers_removed.pdf", width = 20, height = 20)
dev.off()

# Automatic network construction and module detection
norm_count_data <- t(expr_rb_wgcna_filtered)

# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))

# Call the network topology analysis function
sft <- pickSoftThreshold(norm_count_data,
                  powerVector = power,
                  networkType = "signed",
                  verbose = 5)

sft.data <- sft$fitIndices

# visualization to pick power
# ideal power should have signed R^2 > 0.9 and minimal mean connectivity
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_text() +
  geom_hline(yintercept = 0.9, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()

a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_text() +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()
  
grid.arrange(a1, a2, nrow = 2)
dev.copy(png, filename = "wgcna/FRDA_All_Batches_ENSG_genes_removed/wgcna_soft_thresholding_power_selection_all_batch.png", width = 2000, height = 2500, res = 150)
dev.off()

soft_power <- 12
temp_cor <- cor # store original cor function to temporarily override
cor <- WGCNA::cor

# Using unsigned network also included FXN in the grey module
bwnet <- blockwiseModules(norm_count_data,
                 maxBlockSize = 14000,
                 minModuleSize = 20,
                 TOMType = "signed",
                 power = soft_power,
                 mergeCutHeight = 0.15, # modules are merged if eigengene correlation > 1 - mergeCutHeight
                 deepSplit = 2, # integer value from 0 to 4 (Higher value indicates sensitive module detection and splitting)
                 numericLabels = TRUE,
                 saveTOMs = TRUE,
                 saveTOMFileBase = "wgcna/FRDA_All_Batches_ENSG_genes_removed/frda_all_batch_wgcna_TOM",
                 randomSeed = 1234,
                 verbose = 3)

saveRDS(bwnet, file = "wgcna/FRDA_All_Batches_ENSG_genes_removed/wgcna_frda_all_batch.rds")
bwnet <- readRDS("wgcna/FRDA_All_Batches_ENSG_genes_removed/wgcna_frda_all_batch.rds")

cor <- temp_cor

module_eigengenes <- bwnet$MEs
table(bwnet$colors)

# Plot the dendrogram and the module colors underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
                    c("unmerged", "merged"),
                    main = "Gene dendogram and module colours",
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
dev.copy(png, filename = "wgcna/FRDA_All_Batches_ENSG_genes_removed/wgcna_gene_dendrogram_all_batch.png", width = 2000, height = 1500, res = 150)
dev.off()

# Relate modules to external traits
metadata_frda_wgcna$Condition_0_1 <- ifelse(metadata_frda_wgcna$Condition == "Control", 0, 1)
metadata_frda_wgcna$`DD x GAA1` <- as.numeric(metadata_frda_wgcna$DD) * as.numeric(metadata_frda_wgcna$GAA1)

col_to_fill_zero <- c("HCM", "DD", "DD x GAA1")
metadata_frda_wgcna[col_to_fill_zero] <- lapply(metadata_frda_wgcna[col_to_fill_zero], function(x) {
  x[is.na(x)] <- 0
  return(x)
})

col_to_num_convert <- c("HCM", "DD", "DD x GAA1")
metadata_frda_wgcna[col_to_num_convert] <- lapply(metadata_frda_wgcna[col_to_num_convert], function(x) {
  as.numeric(as.character(x))
})

trait_data <- metadata_frda_wgcna |> 
  select(Condition_0_1, HCM, GAA1, GAA2, DD, `DD x GAA1`)

nSamples <- nrow(norm_count_data)
nGenes <- ncol(norm_count_data)

module_eigengenes_sort <- module_eigengenes[, order(as.numeric(sub("ME", "", colnames(module_eigengenes))))] |> 
  select(-ME0)

module_trait_cor <- cor(module_eigengenes_sort, trait_data, use = "p", method = "pearson")
module_trait_pvalue <- corPvalueStudent(module_trait_cor, nSamples)

# Heatmap of module-trait relationships
heatmap.data <- merge(module_eigengenes_sort, trait_data, by = 'row.names')
heatmap.data <- heatmap.data |> 
  column_to_rownames(var = 'Row.names')
heatmap.data <- rename(heatmap.data, Condition = Condition_0_1)

module_eigengenes_length <- ncol(module_eigengenes_sort)
trait_data_length <- ncol(trait_data)

png(
  filename = "wgcna/FRDA_All_Batches_ENSG_genes_removed/wgcna_module_trait_relationships_all_batch.png", 
  width = 13, 
  height = 8.5, 
  units = "in", 
  res = 600)
CorLevelPlot(heatmap.data,
             x = names(heatmap.data)[module_eigengenes_length + 1:trait_data_length],
             y = names(heatmap.data)[1:module_eigengenes_length],
             col = c("#398110ff", "#7ecc51ff", "white", "#f7afbeff", "#C93A5A"))
dev.off()

# Extract genes in significant modules
significant_modules <- module_trait_pvalue |> 
  as.data.frame() |> 
  rownames_to_column(var = "Module") |> 
  pivot_longer(-Module, names_to = "Trait", values_to = "pvalue") |> 
  filter(pvalue < 0.05) |> 
  pull(Module) |> 
  unique()

output_list <- list()

# For genes in all modules use rownames(module_trait_cor)
for (mod in significant_modules) {
  mod_color <- sub("ME", "", mod) |> tolower()
  genes_in_module <- names(bwnet$colors)[bwnet$colors == mod_color]
  
  output_list[[mod]] <- data.frame(Gene = genes_in_module)
}

write_xlsx(output_list, "wgcna/FRDA_All_Batches_ENSG_genes_removed/genes_in_significant_modules_all_batch.xlsx")

# Boxplot between patients and controls of significant module eigengenes
boxplot_df <- bwnet$MEs |>
  as.data.frame() |>
  rownames_to_column("Sample") |>
  left_join(metadata_frda_wgcna |> rownames_to_column("Sample"), by = "Sample") |>
  pivot_longer(cols = all_of(colnames(bwnet$MEs)),
              names_to = "Module",
              values_to = "Eigengene") |> 
  filter(Module != "ME0") |> 
  arrange(as.numeric(sub("ME", "", Module))) |> 
  mutate(Module = factor(Module, levels = unique(Module)))

stat_df <- boxplot_df |>
  group_by(Module) |>
  wilcox_test(Eigengene ~ Condition) |>
  adjust_pvalue(method = "BH") |>
  add_significance("p.adj") |>
  left_join(
    boxplot_df |>
      group_by(Module) |>
      summarise(y.position = max(Eigengene, na.rm = TRUE) * 1.1),
    by = "Module"
  ) |>
  filter(p.adj < 0.05) |> 
  arrange(as.numeric(sub("ME", "", Module))) |> 
  mutate(Module = factor(Module, levels = unique(Module)))

boxplot_df_sig <- boxplot_df |>
  filter(Module %in% stat_df$Module)

plot <- ggplot(
  boxplot_df_sig,
  aes(x = Condition, y = Eigengene, fill = Condition)
) +
  geom_boxplot(
    outlier.shape = NA,
    alpha = 0.7,
    width = 0.35,
    median.linewidth = 0.2
  ) +
  stat_pvalue_manual(
    stat_df,
    label = "p.adj.signif",
    size = 2,
    tip.length = 0.03,
    y.position = "y.position"
  ) +
  scale_fill_manual(values = c(
    "Control" = "#3B8BC2",
    "Patient" = "#C93A5A"
  )) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +
  facet_wrap(~ Module, scales = "free_y") +
  theme_pubclean(base_size = 7) +
  labs(
    title = NULL,
    x = NULL,
    y = "Module Eigengene"
  ) +
  theme(
    strip.text = element_text(size = 5, face = "bold"),
    axis.title.y = element_text(size = 5),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 4),
    axis.ticks.x = element_blank(),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_text(size = 5, face = "bold"),
    legend.text = element_text(size = 4, face = "bold")
  )
ggsave(
  "wgcna/FRDA_All_Batches_ENSG_genes_removed/boxplot_significant_modules.png",
  plot = plot,
  device = "png",
  units = "in",
  height = 2.8,
  width = 3.8,
  dpi = 600
)

# Enrichment analysis for genes in significant modules
GO_enrichment_results <- list()
onts <- c("BP", "CC", "MF")

for (mod in significant_modules) {
  for (go_term in onts){
    message("Processing module: ", mod)
    genes_in_module <- output_list[[mod]]$Gene

    if (length(genes_in_module) < 5) {
      message("Skipping module ", mod, ": too few genes")
      next
    }

    go_enrich <- enrichGO(
      gene = genes_in_module,
      OrgDb = org.Hs.eg.db,
      keyType = "SYMBOL",
      ont = go_term,
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.05,
      readable = TRUE
    )
    GO_enrichment_results[[mod]] <- go_enrich
    go_df <- as.data.frame(go_enrich)

    if (nrow(go_df) == 0) {
      message("No significant GO terms for module ", mod)
      next
    }

    go_df <- go_df |>
  mutate(
    GeneRatio_num = as.numeric(sub("/.*", "", GeneRatio)) / as.numeric(sub(".*/", "", GeneRatio)),
    Description_short = str_trunc(Description, width = 35)
  ) |>
  arrange(p.adjust) |>
  slice_head(n = 20)

    p <- ggplot(
      go_df,
      aes(
        x = GeneRatio_num,
        y = reorder(Description, GeneRatio_num),
        size = Count,
        color = p.adjust
      )
    ) +
      geom_point() +
      scale_color_continuous(
        low = "red",
        high = "blue",
        trans = "reverse",
        name = "Adj. p-value"
      ) +
      labs(
        title = paste0("GO ", go_term," Enrichment\nModule ", mod),
        x = "Gene Ratio",
        y = NULL,
        size = "Gene count"
      ) +
      theme_bw() +
      theme(
        plot.title = element_text(face = "bold"),
        axis.text.y = element_text(size = 9)
      )

    ggsave(
      filename = paste0("wgcna/FRDA_All_Batches_ENSG_genes_removed/GO_BP_module_", mod, ".png"),
      plot  = p,
      width = 10,
      height = 6,
      dpi   = 300
    )
  }
}

write.xlsx(GO_enrichment_results, "wgcna/FRDA_All_Batches_ENSG_genes_removed/go_enrichment_significant_modules_all_batch.xlsx")

# Enrichment analysis for significant modules using Enrichr
websiteLive <- getOption("enrichR.live")

dbs <- c("Reactome_Pathways_2024",
         "WikiPathways_2024_Human",
         "KEGG_2019_Human")

enrichr_results <- list()

if (websiteLive) {
  for (mod in significant_modules) {
  genes_in_module <- output_list[[mod]]$Gene
  
  enrichr_enrich <- enrichr(genes_in_module, dbs)

  for (db in names(enrichr_enrich)) {
    enrichr_results[[paste0(mod, "_", db)]] <- enrichr_enrich[[db]]

    p <- plotEnrich(enrichr_enrich[[db]], showTerms = 20, y = "Count", orderBy = "FDR", title = paste0("Enrichr ", db, " for Module ", mod))
    
    ggsave(paste0("wgcna/FRDA_All_Batches_ENSG_genes_removed/enrichr_", gsub(" ", "_", tolower(db)), "_module_", mod, "_all_batch.png"),
           plot = p,
           width = 10,
           height = 6,
           dpi = 300)
  }
}}

clean_name <- function(x) substr(x, 1, 31)
names(enrichr_results) <- sapply(names(enrichr_results), clean_name)
write.xlsx(enrichr_results, "wgcna/FRDA_All_Batches_ENSG_genes_removed/enrichr_significant_modules_all_batch.xlsx")

# Plot for important modules from WGCNA
for(mod in (boxplot_df_sig |> pull(Module) |> unique())){
  df <- read_excel("wgcna/FRDA_All_Batches_ENSG_genes_removed/enrichr_significant_modules_all_batch.xlsx", sheet = paste0(mod, "_Reactome_Pathways_2024"))

  pathway_plot <- df |> 
  mutate(
    GeneNum = as.numeric(sub("/.*", "", Overlap)),
    Term_short = str_trunc(Term, width = 35),
    negLogAdjP = -log10(Adjusted.P.value)
  ) |>
  arrange(desc(negLogAdjP)) |>
  slice_head(n = 20)

  p <- ggplot(
  pathway_plot,
  aes(
    x = GeneNum,
    y = reorder(Term_short, negLogAdjP),
    fill = negLogAdjP
  )
) +
  geom_col(width = 0.7) +
  scale_fill_gradient(
    low = "#3B8BC2",
    high = "#C93A5A",
    name = expression(bold(-log[10]("adj p")))
  ) +
  labs(
    x = "Gene count",
    y = NULL
  ) +
  theme_minimal(base_size = 7) +
  guides(
  fill = guide_colourbar(
    barheight = unit(1.5, "cm"),
    barwidth  = unit(0.25, "cm")
    )
  ) +
  theme(
    axis.title.x = element_text(size = 6, face = "bold"),
    axis.text = element_text(size = 4, face = "bold"),
    panel.grid = element_blank(),
    axis.line = element_line(linewidth = 0.3, colour = "grey40"),
    legend.position = "right",
    legend.title = element_text(size = 5),
    legend.text  = element_text(size = 4)
  )
  ggsave(
    paste0("wgcna/FRDA_All_Batches_ENSG_genes_removed/", mod, "_enrichment.png"),
    plot = p,
    device = "png",
    units = "in",
    height = 8.5/3,
    width = 13/3,
    dpi = 600
  )
}

# Analysis focussed on FXN
# Sub-cluster the FXN module only (to find the top genes co-expressed with FXN)
fxn_mod_color <- bwnet$colors["FXN"]
genes_in_fxn_module <- names(bwnet$colors)[bwnet$colors == fxn_mod_color]
length(genes_in_fxn_module)

datExprModule <- norm_count_data[, genes_in_fxn_module] # samples x genes

TOM_mod <- TOMsimilarityFromExpr(datExprModule, power = soft_power, networkType = "signed")
dissTOM <- 1 - TOM_mod

geneTree_mod <- hclust(as.dist(dissTOM), method = "average")
dynamicMods <- cutreeDynamic(dendro = geneTree_mod, distM = dissTOM,
                             deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = 20)

dynamicColors <- labels2colors(dynamicMods)
table(dynamicColors)

fxn_mod_color_new <- dynamicColors[genes_in_fxn_module == "FXN"]
genes_colours <- genes_in_fxn_module
names(genes_in_fxn_module) <- dynamicColors
fxn_coexpressed_genes <- unname(genes_in_fxn_module)[names(genes_in_fxn_module) == fxn_mod_color_new]

# Intramodular connectivity
geneModuleMembership <- as.data.frame(cor(norm_count_data, module_eigengenes, use = "p"))
me_name <- paste0("ME", fxn_mod_color)
kME_fxn <- geneModuleMembership[genes_in_fxn_module, me_name, drop = FALSE]
kME_fxn$gene <- rownames(kME_fxn)
colnames(kME_fxn)[1] <- "kME"

kME_fxn <- kME_fxn[order(-abs(kME_fxn$kME)), ]

top50_hubs <- head(kME_fxn$gene, 50)
top5pct <- head(kME_fxn$gene, ceiling(0.05 * nrow(kME_fxn)))
top_genes_for_network <- head(kME_fxn$gene, 200)
# Neither of these have FXN

datNet <- norm_count_data[, top_genes_for_network]
ADJ1 <- adjacency(datNet, power = soft_power, type = "signed")
TOM_net <- TOMsimilarity(ADJ1)
dissTOM_net <- 1 - TOM_net

exportThreshold <- 0.1 # export edges above threshold (e.g., TOM > 0.1 or top X%)
cyt <- exportNetworkToCytoscape(
  TOM_net,
  edgeFile = "wgcna/FRDA_All_Batches_gene_filtered/cytoscape_edges_FXN_top200.txt",
  nodeFile = "wgcna/FRDA_All_Batches_gene_filtered/cytoscape_nodes_FXN_top200.txt",
  weighted = TRUE,
  threshold = exportThreshold,
  nodeNames = top_genes_for_network,
  altNodeNames = top_genes_for_network,
  nodeAttr = kME_fxn[top_genes_for_network, , drop = FALSE]
)
```

# Stable expression signatures across batches

```{r}
comparison <- read_xlsx("res/comparison_batch8_9_1_7.xlsx", sheet = "Comparison")
# Genes whose expression is consistent when comparing different batches
signature_genes <- comparison |> 
  filter(Overall_LFC_Synchronicity == "TRUE",
          padj_All_Batch < 0.01,
          padj_Batch_1_7 < 0.01,
          padj_Batch_8_9 < 0.01,
          !str_detect(gene_names, "ENSG")) |> 
  pull(gene_names)

# Normalized expression values
dds <- DESeqDataSetFromMatrix(countData = round(count_data_frda_all), 
                              colData = metadata_frda_all, 
                              design = ~1)
dds <- estimateSizeFactors(dds)
vst_obj <- vst(dds, blind = TRUE)
expr_vst <- assay(vst_obj)
expr_filt <- expr_vst[rowMeans(expr_vst) > 5, ] # Removing genes whose average expression across samples is < 5
gene_var <- rowVars(expr_filt)
expr_filt <- expr_filt[gene_var > quantile(gene_var, 0.5), ] # Top 50 % high variance genes
expr_sig <- expr_filt[rownames(expr_filt) %in% signature_genes, ] # Keeping only the signature genes 

y <- factor(metadata_frda_all$Condition, levels = c("Control", "Patient"))
```

# Differentiating FRDA patients from controls using consistent gene expression profiles
```{r, eval=FALSE}
# ROC for each gene
signature_gene_expr_mat <- expr_vst[signature_genes, ]
gene_roc_stats <- map_dfr(rownames(signature_gene_expr_mat), function(gene) {
  expr_gene <- signature_gene_expr_mat[gene, ]
  roc_obj <- roc(response = y, predictor = as.numeric(expr_gene), levels = c("Control", "Patient"), direction = "auto")
  auc_val <- as.numeric(auc(roc_obj))
  # Determine direction of change
  median_control <- median(expr_gene[y == "Control"])
  median_patient <- median(expr_gene[y == "Patient"])

  tibble(Gene = gene,
          AUC = auc_val,
          Direction = ifelse(median_patient > median_control, "Up_in_Patient", "Down_in_Patient"),
          Control_Median = median_control,
          Patient_Median = median_patient)
})

gene_roc_stats <- gene_roc_stats |> arrange(desc(AUC))
print(head(gene_roc_stats, 10))

top_genes <- gene_roc_stats$Gene[1:6]
png("patient_stratification_prediction/patient_control/top_genes_roc.png", width = 1200, height = 800, res = 120) 
par(mfrow = c(2, 3))
for (g in top_genes) {
  roc_obj <- roc(y, as.numeric(signature_gene_expr_mat[g, ]), levels = c("Control", "Patient"), direction = "auto")
  plot(roc_obj, main = paste0(g, " (AUC=", round(auc(roc_obj), 2), ")"), cex.lab = 1.8, cex.axis = 1.2, cex.main = 1.8)
}
par(mfrow = c(1, 1))
dev.off()
graphics.off()

basal_ranges <- map_dfr(rownames(signature_gene_expr_mat), function(gene) {
  ctrl_vals <- signature_gene_expr_mat[gene, y == "Control"]
  tibble(
    Gene = gene,
    Control_Median = median(ctrl_vals),
    Control_Q1 = quantile(ctrl_vals, 0.25),
    Control_Q3 = quantile(ctrl_vals, 0.75),
    Control_Lower_95 = quantile(ctrl_vals, 0.025),
    Control_Upper_95 = quantile(ctrl_vals, 0.975)
  )
})

print(head(basal_ranges))

gene_to_plot <- gene_roc_stats$Gene[1]
boxplot(signature_gene_expr_mat[gene_to_plot, ] ~ y, col = c("skyblue", "salmon"), ylab = "VST Expression", main = paste0(gene_to_plot, " expression"))
abline(h = basal_ranges |> filter(Gene == gene_to_plot) |> pull(Control_Upper_95), lty = 2)

# Calculating average expression of genes for patients and controls
train_centroids <- function(expr, labels) {
  list(patient = rowMeans(expr[, labels == "Patient", drop = FALSE]),
      control = rowMeans(expr[, labels == "Control", drop = FALSE]))
}

# Measures whether a sample's gene-expression pattern is more similar to the control centroid or the patient centroid
signature_score <- function(sample, centroids) {
  cor(sample, centroids$control) - cor(sample, centroids$patient)
}

set.seed(123)
folds <- createFolds(y, k = 10) # Divides the patient-control samples into 10 random clusters

sig_sizes <- c(20, 30, 50, 75) # Size of stable gene signatures that can stratify patients from controls
results_all <- list()
gene_freq <- list()

for (k in sig_sizes) {
  cv_res <- map_dfr(seq_along(folds), function(i) {
    test_idx  <- folds[[i]]
    train_idx <- setdiff(seq_along(y), test_idx)
    expr_train <- expr_sig[, train_idx]
    expr_test  <- expr_sig[, test_idx]
    y_train <- y[train_idx]
    y_test  <- y[test_idx]
    expr_train_bc <- removeBatchEffect(expr_train, batch = metadata_frda_all$Batch[train_idx])
    expr_test_bc <- removeBatchEffect(expr_test, batch = metadata_frda_all$Batch[test_idx])
    # Finding the difference of the medians of genes expression between patients and controls
    gene_effect <- apply(expr_train_bc, 1, function(g) median(g[y_train == "Patient"]) - median(g[y_train == "Control"]))
    ranked_genes <- names(sort(abs(gene_effect), decreasing = TRUE))
    selected_genes <- ranked_genes[1:k] # Genes with the highest differences
    gene_freq[[paste0("k", k, "_fold", i)]] <<- selected_genes
    centroids <- train_centroids(expr_train_bc[selected_genes, ], y_train) # Calculating centroids on the training dataset
    # Identifying whether the centroids can classify patients from controls using the signature score function
    scores <- apply(expr_test_bc[selected_genes, ], 2, signature_score, centroids = centroids)
    tibble(k = k, fold = i, score = scores, truth = y_test)})

  roc_obj <- roc(cv_res$truth, cv_res$score, levels = c("Control", "Patient"), direction = "auto")
  results_all[[as.character(k)]] <- tibble(signature_size = k, AUC = as.numeric(auc(roc_obj)))
}

auc_summary <- bind_rows(results_all)
print(auc_summary)

# Top stable genes present across different signature gene size and fold
gene_table <- sort(table(unlist(gene_freq)), decreasing = TRUE)
stable_genes <- names(gene_table[gene_table >= 7])
stable_genes <- stable_genes[1:50]

# Using the stable genes to calculate final centroid values and signature scores
final_effect <- apply(expr_sig[stable_genes, ], 1, function(g) median(g[y == "Patient"]) - median(g[y == "Control"]))
final_genes <- names(sort(abs(final_effect), decreasing = TRUE))[1:50]
final_centroids <- train_centroids(expr_sig[final_genes, ], y)
scores_all <- apply(expr_sig[final_genes, ], 2, signature_score, centroids = final_centroids)

# Performance evaluation using AUC curve
roc_final <- roc(y, scores_all, levels = c("Control", "Patient"), direction = "auto")
coords_df <- coords(roc_final, x = "best", best.method = "youden", ret = c("threshold", "sensitivity", "specificity"))
threshold <- as.numeric(coords_df["threshold"]) # Identifying the threshold distinguishing patients and controls

saveRDS(list(genes = final_genes, centroids = final_centroids, threshold = threshold), file = "FRDA_diagnostic_signature.rds")

pred_class <- ifelse(scores_all < threshold, "Patient", "Control")

# Confusion matrix
confusionMatrix(factor(pred_class, levels = c("Control", "Patient")), 
                factor(y, levels = c("Control", "Patient")),
                positive = "Patient")

# Threshold separating patients and control
png("patient_stratification_prediction/patient_control/patient_control_stratify.png", width = 1200, height = 800, res = 120) 
boxplot(scores_all ~ y, col = c("skyblue", "salmon"), ylab = "FRDA diagnostic score")
abline(h = threshold, lty = 2)
dev.off()
```

# Stratification of FRDA patients into different severity groups using consistent gene expression profiles

```{r, eval=FALSE}
# Filtering FRDA patients only
frda_patients <- metadata_frda_all[metadata_frda_all$Condition == "Patient", ]

# Converting severity scales to numeric
frda_patients$FSA_scale_num <- as.numeric(frda_patients$`FSA scale`)
frda_patients$mFARS_total_num <- as.numeric(frda_patients$`mFARS total`)
frda_patients$mFARS_USS_num <- as.numeric(frda_patients$`mFARS USS`)

# Total patients with data for each scale
n_fsa <- sum(!is.na(frda_patients$FSA_scale_num))
n_mfars_total <- sum(!is.na(frda_patients$mFARS_total_num))
n_mfars_uss <- sum(!is.na(frda_patients$mFARS_USS_num))

# Histogram for FSA scale
p1 <- ggplot(frda_patients, aes(x = FSA_scale_num)) +
  geom_histogram(bins = 20, fill = "#3B8BC2", color = "black", alpha = 0.7) +
  stat_bin(
    bins = 20,
    geom = "text",
    aes(label = after_stat(count), y = after_stat(count)),
    vjust = -0.5,
    size = 4
  ) +
  scale_x_continuous(breaks = scales::extended_breaks(n = 15)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.12))) +
  theme_bw(base_size = 14) +
  labs(
    x = "FSA Scale",
    y = "Number of Patients",
    title = "Distribution of Patients by FSA Scale",
    subtitle = paste0("Total: ", n_fsa, " patients with FSA scale data")
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.minor = element_blank()
  )

# Histogram for mFARS total
p2 <- ggplot(frda_patients, aes(x = mFARS_total_num)) +
  geom_histogram(bins = 20, fill = "#C93A5A", color = "black", alpha = 0.7) +
  stat_bin(
    bins = 20,
    geom = "text",
    aes(label = after_stat(count), y = after_stat(count)),
    vjust = -0.5,
    size = 4
  ) +
  scale_x_continuous(breaks = scales::extended_breaks(n = 15)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.12))) +
  theme_bw(base_size = 14) +
  labs(
    x = "mFARS Total",
    y = "Number of Patients",
    title = "Distribution of Patients by mFARS Total",
    subtitle = paste0("Total: ", n_mfars_total, " patients with mFARS total data")
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.minor = element_blank()
  )

# Histogram for mFARS USS
p3 <- ggplot(frda_patients, aes(x = mFARS_USS_num)) +
  geom_histogram(bins = 20, fill = "#7ecc51", color = "black", alpha = 0.7) +
  stat_bin(
    bins = 20,
    geom = "text",
    aes(label = after_stat(count), y = after_stat(count)),
    vjust = -0.5,
    size = 4
  ) +
  scale_x_continuous(breaks = scales::extended_breaks(n = 15)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.12))) +
  theme_bw(base_size = 14) +
  labs(
    x = "mFARS USS",
    y = "Number of Patients",
    title = "Distribution of Patients by mFARS USS",
    subtitle = paste0("Total: ", n_mfars_uss, " patients with mFARS USS data")
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.minor = element_blank()
  )

# Combine plots
combined_hist <- p1 / p2 / p3

# Save combined plot
ggsave(
  "patient_stratification_prediction/patient_stratify/severity_scales_histograms.png",
  plot = combined_hist,
  device = "png",
  units = "in",
  height = 12,
  width = 8,
  dpi = 600
)

# Stratification of FRDA patients into mild, moderate, and severe groups using the three severity scales
# Composite severity index using all 3 scales (z-score each scale, then average)
severity_df <- frda_patients |>
  transmute(
    SampleID = rownames(frda_patients),
    FSA = FSA_scale_num,
    mFARS_total = mFARS_total_num,
    mFARS_USS = mFARS_USS_num
  )

z_mat <- as.data.frame(scale(severity_df[, c("FSA", "mFARS_total", "mFARS_USS")]))
names(z_mat) <- paste0(names(z_mat), "_z")

severity_df <- bind_cols(severity_df, z_mat) |>
  mutate(
    n_scales_present = rowSums(!is.na(across(ends_with("_z")))),
    severity_index = rowMeans(across(ends_with("_z")), na.rm = TRUE)
  )

# If a patient has none of the scales, keep index as NA
severity_df$severity_index[severity_df$n_scales_present == 0] <- NA_real_

# Compute tertile cutoffs among patients with at least 2 scales available
eligible <- severity_df |> filter(n_scales_present >= 2, !is.na(severity_index))
cutoffs <- quantile(eligible$severity_index, probs = c(1 / 3, 2 / 3), na.rm = TRUE, names = FALSE)

severity_df <- severity_df |>
  mutate(
    severity_group = case_when(
      n_scales_present < 2 ~ "Insufficient data (<2 scales)",
      severity_index <= cutoffs[1] ~ "Mild",
      severity_index <= cutoffs[2] ~ "Moderate",
      TRUE ~ "Severe"
    ),
    severity_group = factor(
      severity_group,
      levels = c("Mild", "Moderate", "Severe", "Insufficient data (<2 scales)")
    )
  )

# Joining results back to frda_patients
frda_patients <- frda_patients |>
  mutate(SampleID = rownames(frda_patients)) |>
  left_join(
    severity_df |> select(SampleID, severity_index, n_scales_present, severity_group),
    by = "SampleID"
  ) |>
  column_to_rownames("SampleID")

# Counts per group
print(table(frda_patients$severity_group, useNA = "ifany"))

# Counts among patients included in grouping (Mild/Moderate/Severe)
group_n <- frda_patients |>
  filter(severity_group %in% c("Mild", "Moderate", "Severe")) |>
  count(severity_group) |>
  mutate(severity_group = as.character(severity_group))

group_n_named <- setNames(group_n$n, group_n$severity_group)
group_n_named <- group_n_named[c("Mild", "Moderate", "Severe")]
group_n_named[is.na(group_n_named)] <- 0

group_n_total <- sum(group_n_named)

# Distribution of the composite index (cutoffs shown as dashed lines)
p_index <- ggplot(
  frda_patients |> filter(severity_group %in% c("Mild", "Moderate", "Severe")),
  aes(x = severity_index, fill = severity_group)
) +
  geom_histogram(bins = 30, alpha = 0.7, color = "black") +
  geom_vline(xintercept = cutoffs, linetype = 2) +
  scale_fill_manual(
    values = c(Mild = "#7ecc51", Moderate = "#F1A340", Severe = "#C93A5A"),
    breaks = c("Mild", "Moderate", "Severe"),
    labels = c(
      Mild = paste0("Mild (n=", group_n_named[["Mild"]], ")"),
      Moderate = paste0("Moderate (n=", group_n_named[["Moderate"]], ")"),
      Severe = paste0("Severe (n=", group_n_named[["Severe"]], ")")
    )
  ) +
  # scale_y_continuous(expand = expansion(mult = c(0, 0.22))) +
  theme_bw(base_size = 14) +
  labs(
    title = "Composite severity index (FSA + mFARS total + mFARS USS)",
    subtitle = paste0(
      "Severity index = mean(z-scored scales); groups = tertiles among patients with ≥2 scales. ",
      paste0("Patients included: ", group_n_total)
    ),
    x = "Severity index (mean z-score)",
    y = "Number of patients",
    fill = "Group"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.minor = element_blank()
  )

ggsave(
  "patient_stratification_prediction/patient_stratify/severity_index_histogram.png",
  plot = p_index,
  device = "png",
  units = "in",
  height = 8,
  width = 12,
  dpi = 600
)

# Raw scale distributions by composite group
long_scales <- frda_patients |>
  rownames_to_column("SampleID") |>
  filter(severity_group %in% c("Mild", "Moderate", "Severe")) |>
  select(
    SampleID,
    severity_group,
    `FSA scale` = FSA_scale_num,
    `mFARS total` = mFARS_total_num,
    `mFARS USS` = mFARS_USS_num
  ) |>
  pivot_longer(
    cols = c(`FSA scale`, `mFARS total`, `mFARS USS`),
    names_to = "Scale",
    values_to = "Score"
  )

# Per-scale, per-group counts for annotation
count_df <- long_scales |>
  group_by(Scale, severity_group) |>
  summarise(n = n(), .groups = "drop") |>
  left_join(
    long_scales |>
      group_by(Scale) |>
      summarise(y.position = max(Score, na.rm = TRUE) * 1.1, .groups = "drop"),
    by = "Scale"
  )

# Boxplot of raw severity scales by composite group
p_box <- ggplot(long_scales, aes(x = severity_group, y = Score, fill = severity_group)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.15, size = 1.2, alpha = 0.5) +
  geom_text(
    data = count_df,
    aes(x = severity_group, y = y.position, label = paste0("n=", n)),
    inherit.aes = FALSE,
    size = 5
  ) +
  facet_wrap(~Scale, scales = "free_y", ncol = 1) +
  theme_bw(base_size = 15) +
  labs(
    title = "Raw severity scales by composite group",
    x = NULL,
    y = "Score"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "none",
    panel.grid.minor = element_blank()
  )

ggsave(
  "patient_stratification_prediction/patient_stratify/severity_scales_boxplots.png",
  plot = p_box,
  device = "png",
  units = "in",
  height = 12,
  width = 8,
  dpi = 600
)

# Gene-level ROC: Control vs Mild / Moderate / Severe
severity_patients <- frda_patients |>
  rownames_to_column("SampleID") |>
  select(SampleID, severity_group)

metadata_frda_all_ext <- metadata_frda_all |>
  rownames_to_column("SampleID") |>
  left_join(severity_patients, by = "SampleID") |>
  mutate(
    severity_4level = case_when(
      Condition == "Control" ~ "Control",
      severity_group %in% c("Mild", "Moderate", "Severe") ~ as.character(severity_group),
      TRUE ~ NA_character_
    ),
    severity_4level = factor(
      severity_4level,
      levels = c("Control", "Mild", "Moderate", "Severe")
    )
  ) |>
  column_to_rownames("SampleID")

table(metadata_frda_all_ext$severity_4level, useNA = "ifany")

# VST expression (all FRDA + controls) and batch correction
dds_frda_all <- readRDS("dds_frda_all_ensg_removed.rds")
vst_frda_all <- DESeq2::vst(dds_frda_all, blind = TRUE)
expr_vst_all <- assay(vst_frda_all)

# Align expression matrix columns to metadata rows
expr_vst_all <- expr_vst_all[, rownames(metadata_frda_all_ext)]

covs_all <- model.matrix(~ Sex + Age + Condition, data = metadata_frda_all_ext)
expr_rb_all <- limma::removeBatchEffect(
  expr_vst_all,
  batch = metadata_frda_all_ext$Batch,
  design = covs_all
)

# Function to calculate per-gene ROC for patient state vs Control
calc_gene_roc <- function(expr_mat, meta, state_label) {
  keep <- !is.na(meta$severity_4level) & meta$severity_4level %in% c("Control", state_label)
  meta_sub <- meta[keep, , drop = FALSE]
  expr_sub <- expr_mat[, keep, drop = FALSE]

  y <- factor(meta_sub$severity_4level, levels = c("Control", state_label))

  purrr::map_dfr(rownames(expr_sub), function(g) {
    vals <- as.numeric(expr_sub[g, ])

    # Skipping genes with no variation
    if (all(vals == vals[1])) {
      return(tibble(
        gene = g,
        comparison = paste0(state_label, "_vs_Control"),
        AUC = NA_real_,
        Direction = NA_character_,
        Control_median = NA_real_,
        State_median = NA_real_
      ))
    }

    roc_obj <- tryCatch(
      roc(
        response = y,
        predictor = vals,
        levels = c("Control", state_label),
        direction = "auto"
      ),
      error = function(e) NULL
    )

    if (is.null(roc_obj)) {
      return(tibble(
        gene = g,
        comparison = paste0(state_label, "_vs_Control"),
        AUC = NA_real_,
        Direction = NA_character_,
        Control_median = NA_real_,
        State_median = NA_real_
      ))
    }

    auc_val <- as.numeric(auc(roc_obj))
    med_ctrl <- median(vals[y == "Control"])
    med_state <- median(vals[y == state_label])

    tibble(
      gene = g,
      comparison = paste0(state_label, "_vs_Control"),
      AUC = auc_val,
      Direction = ifelse(
        med_state > med_ctrl,
        paste0("Up_in_", state_label),
        paste0("Down_in_", state_label)
      ),
      Control_median = med_ctrl,
      State_median = med_state
    )
  })
}

# Running ROC for each patient state vs Control
roc_results <- map_dfr(
  c("Mild", "Moderate", "Severe"),
  ~ calc_gene_roc(expr_rb_all, metadata_frda_all_ext, .x)
)

# Summary of signal strength
roc_summary <- roc_results |>
  group_by(comparison) |>
  summarise(
    n_genes = n(),
    median_AUC = median(AUC, na.rm = TRUE),
    n_AUC_ge_0_8 = sum(AUC >= 0.8, na.rm = TRUE),
    .groups = "drop"
  )

print(roc_summary)

# Save full per-gene ROC table
dir.create("patient_stratification_prediction/patient_state", recursive = TRUE, showWarnings = FALSE)
writexl::write_xlsx(
  roc_results,
  "patient_stratification_prediction/patient_state/gene_level_ROC_control_vs_states.xlsx"
)

# Differential expression between each patient state and controls
# DGE: Mild vs Control, Moderate vs Control, Severe vs Control
dir.create("res/patient_state", recursive = TRUE, showWarnings = FALSE)
dir.create("volcano_plot/patient_state", recursive = TRUE, showWarnings = FALSE)

run_state_vs_control_dge <- function(state_label) {
  keep <- !is.na(metadata_frda_all_ext$severity_4level) & metadata_frda_all_ext$severity_4level %in% c("Control", state_label)
  meta_sub <- metadata_frda_all_ext[keep, ]
  meta_sub$severity_4level <- factor(meta_sub$severity_4level, levels = c("Control", state_label))
  count_sub <- count_data_frda_all[, rownames(meta_sub)]

  dge(counts = count_sub,
      meta = meta_sub,
      design = ~ Batch + Sex + Age + severity_4level,
      filename = paste0("res/patient_state/res_", state_label, "_vs_Control.xlsx"),
      filename_volcano = paste0("volcano_plot/patient_state/volcano_", state_label, "_vs_Control.jpeg"),
      lfc_threshold = 1,
      padj_threshold = 0.05,
      top_n = 10)
}

res_mild <- run_state_vs_control_dge("Mild")
res_moderate <- run_state_vs_control_dge("Moderate")
res_severe <- run_state_vs_control_dge("Severe")
```